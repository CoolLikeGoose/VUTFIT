<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Izg project: Izg project.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Izg project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Izg project. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#zadani">Zadání projektu do předmětu IZG.</a></li>
<li class="level1"><a href="#jakNaTo">Jak na projekt?</a></li>
<li class="level1"><a href="#izg_enqueueSec">Implementace grafické karty - soubor student/gpu.cpp</a><ul><li class="level2"><a href="#ClearCommandTask">1. Úkol - Obsluha command bufferu - čistění framebuffer</a><ul><li class="level3"><a href="#clear">Test 0 - čištění framebufferu</a></li>
<li class="level3"><a href="#clearPartial">Test 1 - čištění částečného framebufferu</a></li>
</ul>
</li>
<li class="level2"><a href="#BindTask">2. Úkol - Obsluha command bufferu - aktivování objektů</a><ul><li class="level3"><a href="#activateTheory">Teorie</a></li>
<li class="level3"><a href="#bindFBO">Test 2 - bindFramebuffer</a></li>
<li class="level3"><a href="#bindProgram">Test 3 - bindProgram</a></li>
<li class="level3"><a href="#bindVBO">Test 4 - bindVertexArray</a></li>
<li class="level3"><a href="#clearMultipleFBO">Test 5 - zápis do vícero framebufferů</a></li>
</ul>
</li>
<li class="level2"><a href="#drawCmdTask">3. Úkol - kreslící příkazy, jejich číslování a další příkazy</a><ul><li class="level3"><a href="#drawCmdTheory">Teorie</a></li>
<li class="level3"><a href="#drawCmdPractice">Test 6 - spouštění vertex shaderu</a></li>
<li class="level3"><a href="#drawIdPractice">Testy 7-8 - číslování kreslících příkazů - gl_DrawID</a></li>
<li class="level3"><a href="#subCmdPractice">Testy 9-10 - sub command a mix příkazů</a></li>
</ul>
</li>
<li class="level2"><a href="#VertexAssembly">4. Úkol - Kreslení - číslování vrcholů a vertex assembly jednotka</a><ul><li class="level3"><a href="#gl_VertexID">Test 11 - Číslování vrcholů</a></li>
<li class="level3"><a href="#gl_VertexIDIndex32">Test 12 - Číslování vrcholů s indexováním.</a></li>
<li class="level3"><a href="#VSUniforms">Test 13 - Vertex shader by měl dostat konstanty z paměti.</a></li>
<li class="level3"><a href="#VertexPuller_Att">Testy 14-16 - Vertex Atributy, Vertex Assembly jednotka</a></li>
</ul>
</li>
<li class="level2"><a href="#Raster">5. Úkol - naprogramovat Primitive Assembly jednotku, rasterizaci a pouštění fragment shaderu</a><ul><li class="level3"><a href="#rasterPractice">Teorie</a></li>
<li class="level3"><a href="#raster_test">Test 17 - Ověření, že rasterizace produkuje fragmenty</a></li>
<li class="level3"><a href="#pd_test">Test 18 - Ověření, zda počítáte perspektivní dělení.</a></li>
<li class="level3"><a href="#fragCoord_test">Test 19 - Ověření, zda vyrasterizované fragmenty mají správnou 2D pozici.</a></li>
<li class="level3"><a href="#depthInterp_test">Test 20 - Ověření, zda se správně interpoluje hloubka fragmentů.</a></li>
<li class="level3"><a href="#attInterp_test">Testy 21-22 - Ověření, zda se správně interpolují vertex attributy.</a></li>
</ul>
</li>
<li class="level2"><a href="#pfo">6 Úkol - naprogramovat per fragment operace a zápis do framebufferu.</a><ul><li class="level3"><a href="#pfoTheory">Teorie</a></li>
<li class="level3"><a href="#pfo_test">Testy 23-27 - Per-fragment operace</a></li>
</ul>
</li>
<li class="level2"><a href="#clip">7. Úkol - naprogramovat ořez trojúhelníků blízkou ořezovou rovinou</a><ul><li class="level3"><a href="#ClippingTheory">Teorie</a></li>
<li class="level3"><a href="#clippingPractice">Testy 28-31 - ořez</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#drawModelSec">Implementace vykreslování modelů se stíny - soubor student/prepareModel.cpp</a><ul><li class="level2"><a href="#drawModel_fce">8. Úkol - Vykreslování modelů - funkce prepareModel</a><ul><li class="level3"><a href="#modelTraverse">Testy 32-37 - Průchod modelem</a></li>
<li class="level3"><a href="#modelMemory">Testy 38-35 - paměť</a></li>
</ul>
</li>
<li class="level2"><a href="#drawModel_vs">9. Úkol - Vykreslování modelů - vertex shader drawModel_vertexShader</a></li>
<li class="level2"><a href="#drawModel_fs">10. Úkol - Vykreslování modelů - fragment shader drawMode_fragmentShader</a></li>
<li class="level2"><a href="#finalCountDown">11. Úkol - finální render</a></li>
</ul>
</li>
<li class="level1"><a href="#rozdeleni">Rozdělení souborů a složek</a></li>
<li class="level1"><a href="#sestaveni">Sestavení</a></li>
<li class="level1"><a href="#spousteni">Spouštění</a></li>
<li class="level1"><a href="#ovladani">Ovládání</a></li>
<li class="level1"><a href="#testovani">Testování</a></li>
<li class="level1"><a href="#odevzdavani">Odevzdávání</a></li>
<li class="level1"><a href="#chyby">Časté chyby, které nedělejte</a></li>
<li class="level1"><a href="#hodnoceni">Hodnocení</a></li>
<li class="level1"><a href="#soutez">Soutěž</a></li>
<li class="level1"><a href="#zaver">Závěrem</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="zadani"></a>
Zadání projektu do předmětu IZG.</h1>
<div class="image">
<img src="vystup.png" alt=""/>
</div>
 <div class="image">
<object type="image/svg+xml" data="teaser.svg" width="1000" style="pointer-events: none;"></object>
</div>
 <div class="image">
<img src="output.png" alt=""/>
<div class="caption">
Takto by měl vypadat výstup projektu</div></div>
<p>Vašim úkolem je naimplementovat jednoduchou grafickou kartu (gpu). A dále implementovat funkci pro vykreslení modelů. Všechny soubory, které se vás týkají jsou ve složce student/ V souboru <a class="el" href="gpu_8cpp.html" title="This file contains implementation of gpu.">student/gpu.cpp</a> implementujte funkci <a class="el" href="gpu_8hpp.html#a534f9ebe20a4f57bd73b4dfb9bb4b29b">izg_enqueue</a> - funcionalita vámi implementované grafické karty. V souboru <a class="el" href="prepareModel_8cpp.html" title="This file contains functions for model rendering.">student/prepareModel.cpp</a> implementujete funkce <a class="el" href="prepareModel_8hpp.html#af46f2952d390459f20fc55a1eb8f4f30">prepareModel</a>, <a class="el" href="prepareModel_8hpp.html#a0224939bb488063ed7ba3a75659e4616">drawModel_vertexShader</a> a <a class="el" href="prepareModel_8hpp.html#a4fb632ea1b28681c59ef705725611573">drawModel_fragmentShader</a>. Tyto funkce slouží pro zpracování načteného souboru s modelem do paměti grafické karty a command bufferu. Kromě toho se ve složce nachází ještě soubor <a class="el" href="fwd_8hpp.html" title="This file contains forward declarations, structures and constants.">student/fwd.hpp</a> - ten obsahuje deklarace struktur a konstant.</p>
<h1><a class="anchor" id="jakNaTo"></a>
Jak na projekt?</h1>
<p>Projekt se může zdát z prvu obrovský s milioném souborů a všelijakých podivností. Tyto "podivnosti" ale nemusíte řešit. Vše, co se vás týká jsou v podstatě 2 soubory do kterých napíšete váš kód a jeden soubor s deklaracemi struktur pro referenci. Projekt okolo těchto souborů vypadá takto z mnoha důvodů (vytvoření okna, načítaní modelů, testování, ...). A není potřeba se jim zabývat (tedy pokud nechcete vidět vnitřnosti a jak celý projekt funguje). Takže jak na to?<br  />
 Nejprve si vyzkoušejte, jak by to mělo vypadat... </p><div class="fragment"><div class="line"># a mackejte &quot;n&quot; nebo &quot;p&quot; a ovladani mysi</div>
<div class="line">izgProject_windows.exe</div>
<div class="line">izgProject_windows.exe --method 18</div>
<div class="line">izgProject_windows.exe --method 17 --model resources\\models\\thebes_palace\\scene.gltf</div>
<div class="line">izgProject_windows.exe --method 17 --model resources\\models\\tf2\\scene.gltf</div>
<div class="line">izgProject_windows.exe --method 17 --model resources\\models\\china\\china.glb</div>
<div class="line">izgProject_windows.exe --method 17 --model resources\\models\\glorious_duck\\scene.gltf</div>
<div class="line">izgProject_windows.exe --method 17 --model resources\\models\\nyra\\scene.gltf</div>
<div class="line">izgProject_windows.exe --method 17 --model resources\\models\\peace\\scene.gltf</div>
<div class="line">izgProject_windows.exe --method 17 --model resources\\models\\triss\\scene.gltf</div>
<div class="line">izgProject_windows.exe --method 17 --model resources\\models\\eifel\\scene.gltf</div>
<div class="line"> </div>
<div class="line"># a mackejte &quot;n&quot; nebo &quot;p&quot; a ovladani mysi</div>
<div class="line">./izgProject_linux.bin </div>
<div class="line">./izgProject_linux.bin --method 18</div>
<div class="line">./izgProject_linux.bin --method 17 --model resources/models/thebes_palace/scene.gltf</div>
<div class="line">./izgProject_linux.bin --method 17 --model resources/models/tf2/scene.gltf</div>
<div class="line">./izgProject_linux.bin --method 17 --model resources/models/china/china.glb</div>
<div class="line">./izgProject_linux.bin --method 17 --model resources/models/glorious_duck/scene.gltf</div>
<div class="line">./izgProject_linux.bin --method 17 --model resources/models/nyra/scene.gltf</div>
<div class="line">./izgProject_linux.bin --method 17 --model resources/models/peace/scene.gltf</div>
<div class="line">./izgProject_linux.bin --method 17 --model resources/models/triss/scene.gltf</div>
<div class="line">./izgProject_linux.bin --method 17 --model resources/models/eifel/scene.gltf</div>
</div><!-- fragment --><p> Jak je to složité? Můj kód pro izg_enqueue má ~600 řádků a implementace prepareModel a shaderů ~100 řádku. Není potřeba nic alokovat, pamět je již předchystaná. Takže pokud budete někde volat malloc, new a podobně, zamyslete se. Z C++ se nevyužívá skoro nic (jen vector a knihovna glm, reference). Takže by to mělo jít napsat celkem v pohodě i pro C lidi.</p>
<ol>
<li>
Vyzkoušet si přiložený zkompilovaný referenční projekt izgProject_linux.bin a izgProject_windows.exe. (mačkejte "n" nebo "p", když projekt pustíte, abyste přepínali zobrazované metody). </li>
<li>
<a class="el" href="index.html#sestaveni">Zprovoznit si překlad</a> </li>
<li>
<a class="el" href="index.html#spousteni">Zkusit si projekt pustit a podívat se naparametry příkazové řádky.</a> a <a class="el" href="index.html#ovladani">jak se aplikace ovládá</a> </li>
<li>
V projektu jsou přítomy <a class="el" href="index.html#testovani">akceptační testy</a>, které vám řeknou, jestli jede správným směrem a taky vypisují napovědu. </li>
<li>
Začít implementovat funkci <a class="el" href="gpu_8hpp.html#a534f9ebe20a4f57bd73b4dfb9bb4b29b">izg_enqueue</a> a kontrolovat váš postup podle přiložených testů. </li>
<li>
Začít implementovat funkci <a class="el" href="prepareModel_8hpp.html#af46f2952d390459f20fc55a1eb8f4f30">prepareModel</a> </li>
<li>
Začít implementovat funkci <a class="el" href="prepareModel_8hpp.html#a0224939bb488063ed7ba3a75659e4616">drawModel_vertexShader</a> </li>
<li>
Začít implementovat funkci <a class="el" href="prepareModel_8hpp.html#a4fb632ea1b28681c59ef705725611573">drawModel_fragmentShader</a> </li>
<li>
Ověřte si implementaci na merlinovi </li>
<li>
<a class="el" href="index.html#odevzdavani">Odevzdávání</a> Odevzdejte </li>
<li>
??? </li>
<li>
profit </li>
</ol>
<p>Každý úkol má přiřazen akceptační test, takže si můžete snadno ověřit funkčnosti vaší implementace. <br  />
<br  />
 Úkoly lze rozdělit do dvou částí: implementace grafické karty a implementace kreslení modelů se stíny.</p>
<h1><a class="anchor" id="izg_enqueueSec"></a>
Implementace grafické karty - soubor student/gpu.cpp</h1>
<p>První věc, na co se asi ptáte: "Jak vypadá počítač", "Jak vypadá grafická karta, jak se s ní komunikuje a co je její chování?"<br  />
 Cílem této části je tvorba grafické karty. Chtěli jste si někdy vytvořit grafickou kartu? Ne? A chcete alespoň vědět, jak se vykreslují počítačové hry a jak funguje svět real-time počítačové grafiky? Základem je počítač s procesorem a grafickou kartou: </p><div class="image">
<object type="image/svg+xml" data="cpu_gpu.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Přehled toho, jak vypadá počítač. S grafickou kartou se komunikuje pomocí fronty příkazů, po které se posílají balíčky práce - Command Buffery.</div></div>
<p> Jak je vidět, tak s grafickou kartou se komunikuje pomocí fronty příkazů (v tomto projektu není), po které se posílají balíčky práce. Balíček práce (<a class="el" href="structCommandBuffer.html">CommandBuffer</a>) v sobě obsahuje mnoho úkolů, které má grafická karta provést. </p><div class="image">
<object type="image/svg+xml" data="commandBuffer.svg" width="150" style="pointer-events: none;"></object>
<div class="caption">
Balíček práce - Command Buffer. Command buffer obsahuje příkazy pro grafickou kartu. Může jich být mnoho, třeba pro vykreslení celého modelu.</div></div>
<p> Koncept command bufferu lze najít například ve Vulkánu: <a href="https://docs.vulkan.org/spec/latest/chapters/cmdbuffers.html">CommandBuffer</a>. Balíček práce se vždy provede nad pamětí grafické karty. Toto fungování grafické karty je zajištěno (bude, až to naprogramujete) funkcí <a class="el" href="gpu_8hpp.html#a534f9ebe20a4f57bd73b4dfb9bb4b29b">izg_enqueue</a>.</p>
<p>Funkce <a class="el" href="gpu_8hpp.html#a534f9ebe20a4f57bd73b4dfb9bb4b29b">izg_enqueue</a> se nachází v <a class="el" href="gpu_8cpp.html" title="This file contains implementation of gpu.">student/gpu.cpp</a>. Je to funkce, která reprezentuje chování grafické karty. Lze pomocí ní kreslit trojúhelníky, mazat framebuffer, nastavovat číslo vykreslovacího příkazu nebo nastavovat aktivní objekty. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="gpu_8cpp.html#a534f9ebe20a4f57bd73b4dfb9bb4b29b">izg_enqueue</a>(<a class="code" href="structGPUMemory.html">GPUMemory</a>&amp;mem,<a class="code" href="structCommandBuffer.html">CommandBuffer</a> <span class="keyword">const</span>&amp;cb){</div>
<div class="line">  (void)mem;</div>
<div class="line">  (void)cb;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Vašim úkolem je ji postupně naprogramovat. Na jeden pokus ji nenaprogramujete, budete ji programovat postupně. Doporučuji si kousky funkce dávat do vlastních podfunkcí, ať máte kód přehledný.<br  />
 <br  />
 Funkce <a class="el" href="gpu_8hpp.html#a534f9ebe20a4f57bd73b4dfb9bb4b29b">izg_enqueue</a> bere dva vstupní parametry: </p><ul>
<li>
paměť grafické karty <a class="el" href="structGPUMemory.html">GPUMemory</a>, nad kterou jsou vykonávány všechny operace, </li>
<li>
<a class="el" href="structCommandBuffer.html">CommandBuffer</a> - seznam operací k provedení. </li>
</ul>
<p>Paměť grafické karty: </p><div class="image">
<object type="image/svg+xml" data="GPUMemory.svg" width="600" style="pointer-events: none;"></object>
<div class="caption">
Struktura paměti grafické karty je složena z několika objektů a čísel. Do framebufferů se kreslí, programy říkají, jak věci kreslit, vertex array říká, kde a jak jsou uloženy data, buffery jsou data, textury jsou obrázky, uniformy jsou konstanty pro programy, gl_DrawID je číslo vykresovacího příkazu, a proměnné activated* slouží pro výběr objektů, které jsou v daný moment aktivní.</div></div>
<p> Výpis <a class="el" href="structGPUMemory.html">GPUMemory</a> ze souboru <a class="el" href="fwd_8hpp.html" title="This file contains forward declarations, structures and constants.">student/fwd.hpp</a> </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structGPUMemory.html">GPUMemory</a>{</div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#aa73d331b9be494e550928fad4ac6c23d">maxUniforms</a>          = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#a3798310241309de18f5561931d1d2665">maxVertexArrays</a>      = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#a8fa73be85fde25818e8b63d71fd7dd60">maxTextures</a>          = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#a0be973077c6d15f40e31d0781b1ea8e6">maxBuffers</a>           = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#aa8e57983bda33e4ef48e825d5bf261eb">maxPrograms</a>          = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#ad9cda42fea22fb0d5347a91f101d15d2">maxFramebuffers</a>      = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#a7f32178fb1950dde77a2133bb93bbe5b">defaultFramebuffer</a>   = 0      ; </div>
<div class="line">  <a class="code" href="structBuffer.html">Buffer</a>      *<a class="code" href="structGPUMemory.html#a4755d327262c8020766718bb31f92d0b">buffers</a>              = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="structTexture.html">Texture</a>     *<a class="code" href="structGPUMemory.html#ac07704dd918f18a48644abdabbdf6f0d">textures</a>             = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="unionUniform.html">Uniform</a>     *<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>             = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="structProgram.html">Program</a>     *<a class="code" href="structGPUMemory.html#a50091de928f20fa9d84c6bd137dab3a6">programs</a>             = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="structFramebuffer.html">Framebuffer</a> *<a class="code" href="structGPUMemory.html#abd0d80589104a936db46ae766bc7975e">framebuffers</a>         = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="structVertexArray.html">VertexArray</a> *<a class="code" href="structGPUMemory.html#acab4bb492d24e78131d39ea7997266cb">vertexArrays</a>         = <span class="keyword">nullptr</span>; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#acd06344c1c43bef8df606d6664fee4b4">activatedFramebuffer</a> = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#a7b289e72424eb0cf9b7aa920386f7565">activatedProgram</a>     = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#af2f8e1efb9217022ced48eeb04b79810">activatedVertexArray</a> = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#aa6541055bfd7af94a91f35bfe0cd9aad">gl_DrawID</a>            = 0      ; </div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Do not worry about these.</span></div>
<div class="line">  <span class="comment">//This is just to suppress valgrind warnings because of the large stack.</span></div>
<div class="line">  <span class="comment">//Otherwise everything would be placed on the stack and not on the heap.</span></div>
<div class="line">  <span class="comment">//I had to allocated this structure on the heap, because it is too large.</span></div>
<div class="line">  <a class="code" href="structGPUMemory.html#a9b333f6f69347068f349d05961c7bf39">GPUMemory</a>();                 </div>
<div class="line">  <a class="code" href="structGPUMemory.html#a9b333f6f69347068f349d05961c7bf39">GPUMemory</a>(<a class="code" href="structGPUMemory.html">GPUMemory</a> <span class="keyword">const</span>&amp;o);</div>
<div class="line">  <a class="code" href="structGPUMemory.html#aba0548cad16f8557782a5b2a409685b0">~GPUMemory</a>();                </div>
<div class="line">  <a class="code" href="structGPUMemory.html">GPUMemory</a>&amp;<a class="code" href="structGPUMemory.html#a59c169462c028204dfca9b92f5cd9230">operator=</a>(<a class="code" href="structGPUMemory.html">GPUMemory</a> <span class="keyword">const</span>&amp;o);</div>
<div class="line">};</div>
</div><!-- fragment --><p> Operace v command bufferu: </p><div class="image">
<object type="image/svg+xml" data="commandTypes.svg" width="600" style="pointer-events: none;"></object>
<div class="caption">
Příkazy jsou uloženy v CommandBufferu. Příkaz může být sedmi druhů. Čistící příkaz čistí aktivovaný framebuffer, kreslící příkaz kreslí s využitím aktivovaného programu a vertex array do aktivovaného framebufferu, setDrawID nastavuje číslo kreslícího příkazu, bindFramebuffer volí, který framebuffer je aktivní, bindProgram volí, který program je aktivní, bindVertexArray volí, který vertex array objekt je aktivní a subCommand obsahuje odkaz na další CommandBuffer.</div></div>
<p> Výpis <a class="el" href="structCommandBuffer.html">CommandBuffer</a> ze souboru <a class="el" href="fwd_8hpp.html" title="This file contains forward declarations, structures and constants.">student/fwd.hpp</a> </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structCommandBuffer.html">CommandBuffer</a>{</div>
<div class="line">  uint32_t <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structCommandBuffer.html#a94aad407c5115fdcd040134eef20b76b">maxCommands</a>           = 10000; </div>
<div class="line">  uint32_t              <a class="code" href="structCommandBuffer.html#a5a4e731514b5998dad67189ca3612f3e">nofCommands</a>           = 0    ; </div>
<div class="line">  <a class="code" href="structCommand.html">Command</a>               <a class="code" href="structCommandBuffer.html#addba1f7b3ffb5ad52a484d1b815436df">commands</a>[<a class="code" href="structCommandBuffer.html#a94aad407c5115fdcd040134eef20b76b">maxCommands</a>]        ; </div>
<div class="line">};</div>
</div><!-- fragment --><p> Jak můžete vidět, obsahuje tři položky: maximální počet příkazů, který může být uložen, počet uložených příkazů a samotné příkazy.<br  />
 Naše grafická karta umožňuje několik druhů práce: </p><ul>
<li>
čistění framebufferu, </li>
<li>
kreslení do framebufferu, </li>
<li>
nastavování čísla kreslícího příkazu, </li>
<li>
navázání aktivního framebufferu, </li>
<li>
navázání aktivního shader programu, </li>
<li>
navázání aktivního vertex array objektu, </li>
<li>
sub command. </li>
</ul>
<p>Struktura samotného příkazu vypadá takto: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structCommand.html">Command</a>{</div>
<div class="line">  <a class="code" href="unionCommandData.html">CommandData</a> <a class="code" href="structCommand.html#ab4bcc3a5664498309ec42d4bb0e1c872">data</a>                     ;</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352">CommandType</a> <a class="code" href="structCommand.html#afd23b7e189739dbae6c0f2e93ba02c81">type</a> = <a class="code" href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352aba2b45bdc11e2a4a6e86aab2ac693cbb">CommandType::EMPTY</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Je složena z typu a dat. Typ je enum: </p><div class="fragment"><div class="line"><span class="keyword">enum class</span> <a class="code" href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352">CommandType</a>{</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#addfd10ead04eeadec78064481a4a3f4daba2b45bdc11e2a4a6e86aab2ac693cbb">EMPTY</a>           , </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352a813461e0c58e7ad59a2fd83ca2237fec">CLEAR</a>           , </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352af33727905f5b6f48cac50cb735ed9524">SET_DRAW_ID</a>     , </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352a2b4807f24940ca2fe73284bc6e864d66">DRAW</a>            , </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352ac9e3011a04cc978bf737d10d2b73f4b7">BIND_FRAMEBUFFER</a>, </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352ac539ee5fafd5847e0877fc545dde6093">BIND_PROGRAM</a>    , </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352af579b0c380b4a2da14f78e233e2a44f6">BIND_VERTEXARRAY</a>, </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352aadcc01dbaca0f0d3fb64ef8f45550ec3">SUB_COMMAND</a>     , </div>
<div class="line">};</div>
</div><!-- fragment --><p> A data je union: </p><div class="fragment"><div class="line"><span class="keyword">union </span><a class="code" href="unionCommandData.html">CommandData</a>{</div>
<div class="line">  <a class="code" href="unionCommandData.html">CommandData</a>():<a class="code" href="unionCommandData.html#a160c967b3ad7619a90a4d40ace1d806e">drawCommand</a>(){}</div>
<div class="line">  <a class="code" href="structClearCommand.html">ClearCommand</a>            <a class="code" href="unionCommandData.html#aa22d28e0590e0c57ec11a8184ea02d3c">clearCommand</a>          ;</div>
<div class="line">  <a class="code" href="structDrawCommand.html">DrawCommand</a>             <a class="code" href="unionCommandData.html#a160c967b3ad7619a90a4d40ace1d806e">drawCommand</a>           ;</div>
<div class="line">  <a class="code" href="structSetDrawIdCommand.html">SetDrawIdCommand</a>        <a class="code" href="unionCommandData.html#a65398ff2cc6bd213bcbd8ac5cff5f734">setDrawIdCommand</a>      ;</div>
<div class="line">  <a class="code" href="structBindFramebufferCommand.html">BindFramebufferCommand</a>  <a class="code" href="unionCommandData.html#a413e8640a4a2e25636d4042f8d781c3e">bindFramebufferCommand</a>;</div>
<div class="line">  <a class="code" href="structBindProgramCommand.html">BindProgramCommand</a>      <a class="code" href="unionCommandData.html#a300ba13d9d8bb7dbdb61bd067a7a68e1">bindProgramCommand</a>    ;</div>
<div class="line">  <a class="code" href="structBindVertexArrayCommand.html">BindVertexArrayCommand</a>  <a class="code" href="unionCommandData.html#aef83fe6c79c6a7d82c142d9e965f0125">bindVertexArrayCommand</a>;</div>
<div class="line">  <a class="code" href="structSubCommand.html">SubCommand</a>              <a class="code" href="unionCommandData.html#a8c895d0453562852f0082254858de113">subCommand</a>            ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Union je něco jako struktura až na to, že jeho velikost je daná největší komponentou. Data unionu jsou uložena přes sebe a je možné uložit jen jednu komponentu. Vzhledem k tomu, že jsem projekt psal v C++, je přítomen i konstruktor, ale toho si nemusíte všímat, jen udává, na co bude union inicializovaný - na draw command. Union obsahuje příkaz pro čistění framebuffer nebo kreslení. </p>
<h2><a class="anchor" id="ClearCommandTask"></a>
1. Úkol - Obsluha command bufferu - čistění framebuffer</h2>
<p>Vašim prvním úkolem bude naprogramovat obsluhu command bufferu. Nejprve zprovozněte čistění framebufferu (<a class="el" href="structFramebuffer.html">Framebuffer</a>). K tomuto úkolu se váže test 0 a 1 (je uvedeno jen Linuxové spouštění testů, na windows je to velmi obdobné):<br  />
 </p><div class="fragment"><div class="line">./izgProject -c --test 1 --up-to-test</div>
</div><!-- fragment --><p> <a class="el" href="structFramebuffer.html" title="This structure represent a framebuffer A framebuffer is used as an output of rendering.">Framebuffer</a> je složen ze dvou bufferů: paměť barvy (color buffer) a paměť hloubky (depth buffer): </p><div class="image">
<object type="image/svg+xml" data="framebuffer.svg" width="400" style="pointer-events: none;"></object>
<div class="caption">
Framebuffer - dva buffery: color buffer a depth buffer o stejném rozlišení. Framebuffer je plátno, kam se kreslí.</div></div>
<p> Oba dva mají stejné rozlišení. Barevný buffer má několik kanálů (až čtyři), každý má stejnou velikost a typ. Hlouboký buffer má hloubku uloženou ve floatech. <a class="el" href="structFramebuffer.html" title="This structure represent a framebuffer A framebuffer is used as an output of rendering.">Framebuffer</a> je koncipován tak, že pixel na souřadnicích [0,0] je v levém dolním rohu, osa X je doprava a oxy Y nahoru. Je možné jej přetočit vzhůru nohama pomocí příznaku <a class="el" href="structFramebuffer.html#a5227afe8482c1670d87d34cf61ec08da">Framebuffer::yReversed</a>. </p><div class="image">
<object type="image/svg+xml" data="yReversed.svg" width="400" style="pointer-events: none;"></object>
<div class="caption">
Framebuffer může být překlopený vzhůru nohama. Je to určeno komponentou yReversed. V taktovém případě je nultý pixel v levém horním rohu framebufferu.</div></div>
<p>Všechny framebuffery se nachází v paměti grafické karty (<a class="el" href="structGPUMemory.html">GPUMemory</a>): </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structFramebuffer.html">Framebuffer</a>{</div>
<div class="line">  <a class="code" href="structImage.html">Image</a>    <a class="code" href="structFramebuffer.html#aaaf692c4a3881fdd17df05c0d9b0811f">color</a>            ; </div>
<div class="line">  <a class="code" href="structImage.html">Image</a>    <a class="code" href="structFramebuffer.html#ad56ef80596abe229e99657865ae8a79b">depth</a>            ; </div>
<div class="line">  uint32_t <a class="code" href="structFramebuffer.html#ad2efd3ac1249da4ce70d478cd48d0e22">width</a>     = 0    ; </div>
<div class="line">  uint32_t <a class="code" href="structFramebuffer.html#a614fd13812430c2ffb379b3b050780c4">height</a>    = 0    ; </div>
<div class="line">  <span class="keywordtype">bool</span>     <a class="code" href="structFramebuffer.html#a5227afe8482c1670d87d34cf61ec08da">yReversed</a> = <span class="keyword">false</span>; </div>
<div class="line">};</div>
</div><!-- fragment --><p> <a class="el" href="structFramebuffer.html" title="This structure represent a framebuffer A framebuffer is used as an output of rendering.">Framebuffer</a> je poměrně složitá struktura. Je složena ze: </p><ul>
<li>
dva <a class="el" href="structImage.html">Image</a> - barva a hloubka, </li>
<li>
šířka, </li>
<li>
výška, </li>
<li>
yReversed - v případě, že je framebuffer vzhůru nohama. </li>
</ul>
<p><a class="el" href="structImage.html">Image</a> je struktura obsahující 2D data. Je využívána u framebufferů a textur. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structImage.html">Image</a>{</div>
<div class="line">  <span class="keyword">enum</span> <a class="code" href="structImage.html#afe74defc826aae605cb2214cbf34c5eb">Channel</a>{</div>
<div class="line">    RED   = 0,</div>
<div class="line">    GREEN    ,</div>
<div class="line">    BLUE     ,</div>
<div class="line">    ALPHA    ,</div>
<div class="line">  };</div>
<div class="line">  <span class="keyword">enum</span> <a class="code" href="structImage.html#a1d53cd4fd9e5b67d38d49bc2c5ebd0db">Format</a>{</div>
<div class="line">    UINT8  ,</div>
<div class="line">    FLOAT32,</div>
<div class="line">  };</div>
<div class="line">  <span class="keywordtype">void</span>*    <a class="code" href="structImage.html#a2d9eabf3628b454331420e4b377538b9">data</a>            = nullptr               ; </div>
<div class="line">  uint32_t <a class="code" href="structImage.html#af20c22715fcc14fe41d929a5127ac897">channels</a>        = 4                     ; </div>
<div class="line">  <a class="code" href="structImage.html#a1d53cd4fd9e5b67d38d49bc2c5ebd0db">Format</a>   <a class="code" href="structImage.html#a98d0e7ac2ffeca933536b705cbdc5dba">format</a>          = UINT8                 ; </div>
<div class="line">  <a class="code" href="structImage.html#afe74defc826aae605cb2214cbf34c5eb">Channel</a>  <a class="code" href="structImage.html#a86d38f6adc2c4bc8285c908460634eac">channelTypes</a>[4] = {RED,GREEN,BLUE,ALPHA}; </div>
<div class="line">  uint32_t <a class="code" href="structImage.html#a85765e057e50aaa2da6ffd1e7085f52a">pitch</a>           = 0                     ; </div>
<div class="line">  uint32_t <a class="code" href="structImage.html#add6fee24fd0db09ee35432b6541e5018">bytesPerPixel</a>   = 0                     ; </div>
<div class="line">};</div>
</div><!-- fragment --><p> <a class="el" href="structImage.html" title="This structure represents 2D memory of image. 2D images are used as textures and color or depth buffe...">Image</a> je inspirovaný strukturami <a href="https://wiki.libsdl.org/SDL2/SDL_Surface">SDL_Surface</a> a <a href="https://wiki.libsdl.org/SDL2/SDL_PixelFormat">SDL_PixelFormat</a>.<br  />
 Struktura obsahuje několik položek: </p><ul>
<li>
Channel - enum typu kanálů, </li>
<li>
Format - enum formátu kanálů, </li>
<li>
data - ukazatel na začátek, </li>
<li>
channels - počet kanálů, </li>
<li>
format - formát kanálů, </li>
<li>
channelTypes - tabulka mapování čísla kanálu na typ kanálu, </li>
<li>
pitch - šířka řádku v bajtech, </li>
<li>
bytesPerPixel - velikost jednoho pixelu v bajtech. </li>
</ul>
<p>Adresování dat může být poněkud komplikované... </p><div class="fragment"><div class="line"><span class="comment">// Pixel [x,y] začíná na adrese:</span></div>
<div class="line">uint8_t* pixelStart = ((uint8_t*)data) + y*pitch + x*bytesPerPixel;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Pokud jsou data typu float</span></div>
<div class="line"><span class="keywordflow">if</span>(format == Image::FLOAT32){</div>
<div class="line">  <span class="keywordtype">float</span>*pixelf = (<span class="keywordtype">float</span>*)pixelStart;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Kanál 0 odpovídá barvě channelTypes[0]</span></div>
<div class="line">  <span class="comment">// tzn. 0 nemusí být RED</span></div>
<div class="line">  pixelf[0] = 0.5f;</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Pokud jsou data typu uint8_t</span></div>
<div class="line"><span class="keywordflow">if</span>(format == Image::UINT8){</div>
<div class="line">  uint8_t*pixelu = (uint8_t*)pixelStart;</div>
<div class="line">  pixelu[0] = 127;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Čistící příkaz (<a class="el" href="structClearCommand.html">ClearCommand</a>) vypadá takto: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structClearCommand.html">ClearCommand</a>{</div>
<div class="line">  glm::vec4   <a class="code" href="structClearCommand.html#abce5e336f53ec4d984f19e1152e9647d">color</a>      = glm::vec4(0); </div>
<div class="line">  <span class="keywordtype">float</span>       <a class="code" href="structClearCommand.html#a2a045bebfafe570f67eafdeb7ece7779">depth</a>      = 1e10        ; </div>
<div class="line">  <span class="keywordtype">bool</span>        <a class="code" href="structClearCommand.html#a2e5b422adedf1413c8cb8f6d47b5a09c">clearColor</a> = true        ; </div>
<div class="line">  <span class="keywordtype">bool</span>        <a class="code" href="structClearCommand.html#a044a86c021e546d61cd21d24bb2bc3c5">clearDepth</a> = true        ; </div>
<div class="line">};</div>
</div><!-- fragment --><p> Čistící příkaz obsahuje barvu, hloubku a příznaky zda se má čistit paměť barvy a hloubky. Všimněte si, že barva je uložena jako floatový vektor glm::vec4. V tomto vektoru je barva v rozsahu [0,1] typu float. Čistící barvu musíte z toho rozsahu převést na správný typ podle typu barevného bufferu.<br  />
</p>
<p>Takto vypadá pseudokód, jak můžete začít psát: </p><div class="fragment"><div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> clear(<a class="code" href="structGPUMemory.html">GPUMemory</a>&amp;mem,<a class="code" href="structClearCommand.html">ClearCommand</a> cmd){</div>
<div class="line">  <span class="comment">// ukázka čistícího příkazu</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// výběr framebufferu</span></div>
<div class="line">  <a class="code" href="structFramebuffer.html">Framebuffer</a>*fbo = mem.<a class="code" href="structGPUMemory.html#abd0d80589104a936db46ae766bc7975e">framebuffers</a>+mem.<a class="code" href="structGPUMemory.html#acd06344c1c43bef8df606d6664fee4b4">activatedFramebuffer</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// máme čistit barvu framebufferu?</span></div>
<div class="line">  <span class="keywordflow">if</span>(cmd.<a class="code" href="structClearCommand.html#a2e5b422adedf1413c8cb8f6d47b5a09c">clearColor</a>){</div>
<div class="line">    <span class="comment">// obsahuje framebuffer barevný buffer?</span></div>
<div class="line">    <span class="keywordflow">if</span>(fbo-&gt;<a class="code" href="structFramebuffer.html#aaaf692c4a3881fdd17df05c0d9b0811f">color</a>.<a class="code" href="structImage.html#a2d9eabf3628b454331420e4b377538b9">data</a>){</div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="gpu_8cpp.html#a534f9ebe20a4f57bd73b4dfb9bb4b29b">izg_enqueue</a>(<a class="code" href="structGPUMemory.html">GPUMemory</a>&amp;mem,<a class="code" href="structCommandBuffer.html">CommandBuffer</a> <span class="keyword">const</span>&amp;cb){</div>
<div class="line">  <span class="keywordflow">for</span>(uint32_t i=0;i&lt;cb.<a class="code" href="structCommandBuffer.html#a5a4e731514b5998dad67189ca3612f3e">nofCommands</a>;++i){</div>
<div class="line">    <a class="code" href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352">CommandType</a> type = cb.<a class="code" href="structCommandBuffer.html#addba1f7b3ffb5ad52a484d1b815436df">commands</a>[i].<a class="code" href="structCommand.html#afd23b7e189739dbae6c0f2e93ba02c81">type</a>;</div>
<div class="line">    <a class="code" href="unionCommandData.html">CommandData</a> data = cb.<a class="code" href="structCommandBuffer.html#addba1f7b3ffb5ad52a484d1b815436df">commands</a>[i].<a class="code" href="structCommand.html#ab4bcc3a5664498309ec42d4bb0e1c872">data</a>;</div>
<div class="line">    <span class="keywordflow">if</span>(type == <a class="code" href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352a813461e0c58e7ad59a2fd83ca2237fec">CommandType::CLEAR</a>)</div>
<div class="line">      clear(mem,data.<a class="code" href="unionCommandData.html#aa22d28e0590e0c57ec11a8184ea02d3c">clearCommand</a>);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Prosím, dejte se do práce. </p>
<h3><a class="anchor" id="clear"></a>
Test 0 - čištění framebufferu</h3>
<div class="fragment"><div class="line">./izgProject -c --test 0</div>
</div><!-- fragment --><p> Tento test zkouší vyčistit framebuffer. </p>
<h3><a class="anchor" id="clearPartial"></a>
Test 1 - čištění částečného framebufferu</h3>
<div class="fragment"><div class="line">./izgProject -c --test 0</div>
</div><!-- fragment --><p> Tento test zkouší vyčistit částečně specifikovaný framebuffer. Paměť barvy i paměť hloubky může být prázdná (nullptr), v takovém případě čištění neproběhne.</p>
<h2><a class="anchor" id="BindTask"></a>
2. Úkol - Obsluha command bufferu - aktivování objektů</h2>
<p>Cílem této části je správně aktivovat objekty. Vážou se k tomu tyto testy: </p><div class="fragment"><div class="line">./izgProject -c --test 5 --up-to-test</div>
</div><!-- fragment --><p> Opět editujete funkci <a class="el" href="gpu_8hpp.html#a534f9ebe20a4f57bd73b4dfb9bb4b29b">izg_enqueue</a> v souboru <a class="el" href="fwd_8hpp.html" title="This file contains forward declarations, structures and constants.">student/fwd.hpp</a>.<br  />
 </p>
<h3><a class="anchor" id="activateTheory"></a>
Teorie</h3>
<p>Grafická karta obsahuje mnoho objektů. Jsou to: </p><ul>
<li>
textury, </li>
<li>
buffery, </li>
<li>
programy, </li>
<li>
framebuffery, </li>
<li>
vertex array objekty, </li>
<li>
uniformy a další. </li>
</ul>
<p>Některé z těchto objektů se přímo využívají při kreslení. Jsou to objekty: </p><ul>
<li>
framebuffery, </li>
<li>
programy, </li>
<li>
vertex array objekty. </li>
</ul>
<p>Je potřeba vědět, kam se kreslí (<a class="el" href="structFramebuffer.html">Framebuffer</a>), je potřeba vědět jak se kreslí (<a class="el" href="structProgram.html">Program</a>) a je potřeba vědět, odkud se berou data pro kreslení (<a class="el" href="structVertexArray.html">VertexArray</a>). </p><div class="image">
<object type="image/svg+xml" data="ctx_overview.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Přehled objektů, které se přímo účastní při vykresování. VertexArray je něco jako vstup pro vykreslování, jsou v něm 'zakódované' trojúhelníky. Framebuffer je výstupní obrázek, který se kreslí. A program popisuje, jak se věci kreslí.</div></div>
<p> Síla dnešních grafických karet spočívá v jejich programovatelnosti a široké nastavitelnosti. Dnes je možné kreslit to vícero framebufferů, využívat k tomu tisíce programů a mít k tomu milióny objektů. Proto je nutné grafické kartě říct, které objekty jsou v danou chvíli aktivní. V OpenGL se to provádí příkazy: </p><ul>
<li>
<a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindFramebuffer.xhtml">glBindFramebuffer</a> </li>
<li>
<a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUseProgram.xhtml">glUseProgram</a> </li>
<li>
<a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml">glBindVertexArray</a> </li>
</ul>
<p>Podobně je to ve Vulkánu, ale je to tam složitější.<br  />
 </p>
<h3><a class="anchor" id="bindFBO"></a>
Test 2 - bindFramebuffer</h3>
<div class="fragment"><div class="line">./izgProject -c --test 2</div>
</div><!-- fragment --><p> Tento test zkouší, zda funguje command <a class="el" href="structBindFramebufferCommand.html">BindFramebufferCommand</a> </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structBindFramebufferCommand.html">BindFramebufferCommand</a>{</div>
<div class="line">  uint32_t <span class="keywordtype">id</span> = 0; </div>
<div class="line">};</div>
</div><!-- fragment --><p> Pokud se v command bufferu objeví tento příkaz, je nutné nastavit aktivní framebuffer v paměti gpu: <a class="el" href="structGPUMemory.html#acd06344c1c43bef8df606d6664fee4b4">GPUMemory::activatedFramebuffer</a>.</p>
<h3><a class="anchor" id="bindProgram"></a>
Test 3 - bindProgram</h3>
<div class="fragment"><div class="line">./izgProject -c --test 3</div>
</div><!-- fragment --><p> Tento test zkouší, zda funguje command <a class="el" href="structBindProgramCommand.html">BindProgramCommand</a> </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structBindProgramCommand.html">BindProgramCommand</a>{</div>
<div class="line">  uint32_t <span class="keywordtype">id</span> = 0; </div>
<div class="line">};</div>
</div><!-- fragment --><p> Pokud se v command bufferu objeví tento příkaz, je nutné nastavit aktivní program v paměti gpu: <a class="el" href="structGPUMemory.html#a7b289e72424eb0cf9b7aa920386f7565">GPUMemory::activatedProgram</a>.</p>
<h3><a class="anchor" id="bindVBO"></a>
Test 4 - bindVertexArray</h3>
<div class="fragment"><div class="line">./izgProject -c --test 4</div>
</div><!-- fragment --><p> Tento test zkouší, zda funguje command <a class="el" href="structBindVertexArrayCommand.html">BindVertexArrayCommand</a> </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structBindVertexArrayCommand.html">BindVertexArrayCommand</a>{</div>
<div class="line">  uint32_t <span class="keywordtype">id</span> = 0; </div>
<div class="line">};</div>
</div><!-- fragment --><p> Pokud se v command bufferu objeví tento příkaz, je nutné nastavit aktivní vertex array v paměti gpu: <a class="el" href="structGPUMemory.html#af2f8e1efb9217022ced48eeb04b79810">GPUMemory::activatedVertexArray</a>.</p>
<h3><a class="anchor" id="clearMultipleFBO"></a>
Test 5 - zápis do vícero framebufferů</h3>
<div class="fragment"><div class="line">./izgProject -c --test 5</div>
</div><!-- fragment --><p> Tento test zkouší čistit různé framebuffer, ne jen nultý. Čistící příkaz čistí aktivní framebuffer.</p>
<h2><a class="anchor" id="drawCmdTask"></a>
3. Úkol - kreslící příkazy, jejich číslování a další příkazy</h2>
<p>Cílem této části je správně spouštět kreslící příkazy, číslovat je a obsluhovat další příkazy. Vážou se k tomu tyto testy: </p><div class="fragment"><div class="line">./izgProject -c --test 10 --up-to-test</div>
</div><!-- fragment --><p> Opět editujete funkci <a class="el" href="gpu_8hpp.html#a534f9ebe20a4f57bd73b4dfb9bb4b29b">izg_enqueue</a> v souboru <a class="el" href="fwd_8hpp.html" title="This file contains forward declarations, structures and constants.">student/fwd.hpp</a>.<br  />
 </p>
<h3><a class="anchor" id="drawCmdTheory"></a>
Teorie</h3>
<p>Grafická karta je navržena tak, aby se minimalizovaly přenosy CPU &lt;-&gt; GPU. Je to z toho důvodu, že PCIe sběrnice je oproti všem částem nejpomalejší. Snažíme se o to, aby se používalo menší množství větších přenosů data mezi CPU &lt;-&gt; GPU. Velké množství malých přenosů je neefektivní a způsobuje čekání jak na straně CPU, tak na straně GPU. Další věcí, která způsobuje zpomalování kreslení je velké množství samostatných vykresovacích příkazů. Je lepší jedním příkazem vykreslit milión trojúhelníků než miliónem příkazů vykreslit stejný milión trojúhelníků po jedom. Z těchto důvodů vzniky command buffery a další techniky. Dnes je možné pomocí jednoho příkazu vykreslit celou scénu i s mnoha efekty. Příkladem nechť je funkce z OpenGL <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElementsIndirect.xhtml">glDrawElementsIndirect</a>. Nastává však jeden problém. Pokud se vše vykreslí pomocí jednoho volání, jak se každému objektu nastaví správná barva, pozice a materiál?<br  />
 V OpenGL i ve Vulkánu se to řeší pomocí číslování vykreslovacích příkazů <a href="https://www.khronos.org/opengl/wiki/Vertex_Shader/Defined_Inputs">gl_DrawID</a>. Pomocí tohoto čísla je možné typicky v shader programu vybrat správnou modelovou matici, materiál a jiné vlastnosti. Ale co je to vůbec shader program, kde se berou data a jak vůbec funguje vykresování? A co je to vykreslovací řetězec a jak funguje?<br  />
<br  />
 Cílem následujícího výkladu je přiblížit fungování grafické karty.<br  />
</p>
<h3>Grafická karta</h3>
<p>Hlavním účelem grafické karty je převod vektorové grafiky na rastrovou. </p><div class="image">
<object type="image/svg+xml" data="pipeline_overview.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Grafická karta je složena z paměti a zobrazovacího řetězce. Z paměti tečou vrcholy a trojúhelníky, které jsou vyrasterizovány zpět do paměti.</div></div>
<p> Data se čtou z paměti, pak se zpracují zobrazovacím řetězcem (ve kterém běží programy) a výsledek se opět zapíše do paměti. Zobravací řetězec je složitý, lze rozdělit na tři části: vektorová část, rasterizace a rastrová část. Akce/příkaz kreslení operuje nad pamětí: </p><div class="image">
<object type="image/svg+xml" data="ctx_overview.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Vstup, proces, výstup - tak vypadá vykresovací příkaz.</div></div>
<p> Příkaz kreslení je prováděn stejně jako příkaz čistění v grafické kartě. Proces kreslení na grafické kartě probíhá v zobrazovacím řetězci.<br  />
</p>
<h3>Zobrazovací řetězec</h3>
<p>Zobrazovací řetězec je složen ze tří částí: vektorová část, rasterizace, rastrová část. </p><div class="image">
<object type="image/svg+xml" data="pipeline_vector_raster.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Zobrazovací řetězec je složen z vektorové a rastrové části mezi kterými leží rasterizace.</div></div>
<p> Úkolem vektorové části je transformovat vektorovou grafiku, posouvat trojúhelníky a podobně. Úkolem raterizace je vektorové elementy převést na rastr. Úkolem frastrové části je obarvit vyrastrované vektory.<br  />
 Část rasterizace a dál nás v tomto úkolu nezajímá, to až později. Tento test je zaměřený na vektorovou část a to jen na její vstup a vertex shader. </p><h3>Vektorová část zobrazovací řetězec</h3>
<p>Cílem vektorové části je zpravovávat vektorovou grafiku: body, trojúhelníky. Většinou se tím myslí: čtení z paměti a sestavení vrcholů, vyvolání vertex shaderu nad každým vrcholem, sestavení trojúhelníků, ořez, perspektivní dělení a připravení pro rasterizaci (viewport transformace). Rasterizace rasterizuje připravené trojúhelníky a produkuje fragmenty (čtvercové úlomky trojúhelníku, které se nakonec zapíšou do framebufferu). Cílem rastrové části je obarvit tyto fragmenty pomocí fragment shaderu, odfiltrovat fragmenty, které jsou příliš daleko (depth test) a smíchat je s framebufferem (blending).<br  />
 Ze začátku implementace kreslení se budete zabývat pouze vektorovou částí - a to částí před vertex shaderem (včetně). </p><div class="image">
<object type="image/svg+xml" data="pipeline_vector.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Vektorová část je složena z vertex assembly jednotky, vertex processoru a části za vertex shaderem.</div></div>
<p> Vertex assembly jednota se stará o sestavování vrcholů. Vertex processor tyto vrcholy "prožene" uživatelem specifikovaným vertex shaderem. Část za vertex shaderem se stará o sestavení trojúhelníku, jeho ořezu a ztransformování pro rasterizaci.<br  />
 </p><h3>Vertex Processor</h3>
<p>Úkolem vertex processoru je pouštět uživatelem specifikovaný vertex shader. Obvykle provádí transformace vrcholů pomocí transformačních matic. Vertex processor vykonává shader (kus programu), kterému se říká vertex shader. Vstupem vertex shaderu je vrchol <a class="el" href="structInVertex.html">InVertex</a>, výstupem je vrchol <a class="el" href="structOutVertex.html">OutVertex</a>. Dalším (konstatním) vstupem vertex shaderu jsou uniformní proměnné a textury <a class="el" href="structShaderInterface.html">ShaderInterface</a>, které jsou uložené v rámci shader programu. Pokud se uživatel rozhodne vykreslit 5 trojúhelníků je vertex shader spuštěn \( 5 \cdot 3 = 15 \). Jednotlivé spuštění (invokace) vertex shaderu vyžadují nové vstupní vrcholy a produkují nové výstupní vrcholy. To ve výsledku znamená, že se pro každou invokaci vertex shaderu spustí Vertex Assembly jednotka, která sestaví vstupní vrchol. </p><div class="image">
<object type="image/svg+xml" data="vertexShader.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Vizualizace vstupů a výstupů vertex procesoru. Ve vertex procesoru běží vertex shader, který obdrží vstupní vrchol, vyprodukuje výstupní vrchol a obdrží vstupní konstanty (uniformní proměnné a textury a číslo vykreslovacího příkazu).</div></div>
<h3><a class="anchor" id="drawCmdPractice"></a>
Test 6 - spouštění vertex shaderu</h3>
<p>A teď práce. Úkol je zprovoznit spouštění vertex shaderu. K tomtu se váže testy 6<br  />
 </p><div class="fragment"><div class="line">./izgProject -c --test 6</div>
</div><!-- fragment --><p> Při kreslení musíte zavolat vertex shader tolikrát, kolik je zadáno v kreslícím příkazu (<a class="el" href="structDrawCommand.html">DrawCommand</a>). Kreslící příkaz je struktura: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structDrawCommand.html">DrawCommand</a>{</div>
<div class="line">  uint32_t    <a class="code" href="structDrawCommand.html#a4a7376486faf9f07fccb7de82d86566b">nofVertices</a>     = 0    ; </div>
<div class="line">  <span class="keywordtype">bool</span>        <a class="code" href="structDrawCommand.html#aff1a6f40fd082c3a0065b5fa3998a753">backfaceCulling</a> = <span class="keyword">false</span>; </div>
<div class="line">};</div>
</div><!-- fragment --><p> Struktura obsahuje počet vertexů pro vykreslení a číslo programu, který by se měl využít. Programy se nachází v paměti grafické karty <a class="el" href="structGPUMemory.html">GPUMemory</a>. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structGPUMemory.html">GPUMemory</a>{</div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#aa73d331b9be494e550928fad4ac6c23d">maxUniforms</a>          = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#a3798310241309de18f5561931d1d2665">maxVertexArrays</a>      = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#a8fa73be85fde25818e8b63d71fd7dd60">maxTextures</a>          = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#a0be973077c6d15f40e31d0781b1ea8e6">maxBuffers</a>           = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#aa8e57983bda33e4ef48e825d5bf261eb">maxPrograms</a>          = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#ad9cda42fea22fb0d5347a91f101d15d2">maxFramebuffers</a>      = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#a7f32178fb1950dde77a2133bb93bbe5b">defaultFramebuffer</a>   = 0      ; </div>
<div class="line">  <a class="code" href="structBuffer.html">Buffer</a>      *<a class="code" href="structGPUMemory.html#a4755d327262c8020766718bb31f92d0b">buffers</a>              = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="structTexture.html">Texture</a>     *<a class="code" href="structGPUMemory.html#ac07704dd918f18a48644abdabbdf6f0d">textures</a>             = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="unionUniform.html">Uniform</a>     *<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>             = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="structProgram.html">Program</a>     *<a class="code" href="structGPUMemory.html#a50091de928f20fa9d84c6bd137dab3a6">programs</a>             = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="structFramebuffer.html">Framebuffer</a> *<a class="code" href="structGPUMemory.html#abd0d80589104a936db46ae766bc7975e">framebuffers</a>         = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="structVertexArray.html">VertexArray</a> *<a class="code" href="structGPUMemory.html#acab4bb492d24e78131d39ea7997266cb">vertexArrays</a>         = <span class="keyword">nullptr</span>; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#acd06344c1c43bef8df606d6664fee4b4">activatedFramebuffer</a> = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#a7b289e72424eb0cf9b7aa920386f7565">activatedProgram</a>     = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#af2f8e1efb9217022ced48eeb04b79810">activatedVertexArray</a> = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#aa6541055bfd7af94a91f35bfe0cd9aad">gl_DrawID</a>            = 0      ; </div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Do not worry about these.</span></div>
<div class="line">  <span class="comment">//This is just to suppress valgrind warnings because of the large stack.</span></div>
<div class="line">  <span class="comment">//Otherwise everything would be placed on the stack and not on the heap.</span></div>
<div class="line">  <span class="comment">//I had to allocated this structure on the heap, because it is too large.</span></div>
<div class="line">  <a class="code" href="structGPUMemory.html#a9b333f6f69347068f349d05961c7bf39">GPUMemory</a>();                 </div>
<div class="line">  <a class="code" href="structGPUMemory.html#a9b333f6f69347068f349d05961c7bf39">GPUMemory</a>(<a class="code" href="structGPUMemory.html">GPUMemory</a> <span class="keyword">const</span>&amp;o);</div>
<div class="line">  <a class="code" href="structGPUMemory.html#aba0548cad16f8557782a5b2a409685b0">~GPUMemory</a>();                </div>
<div class="line">  <a class="code" href="structGPUMemory.html">GPUMemory</a>&amp;<a class="code" href="structGPUMemory.html#a59c169462c028204dfca9b92f5cd9230">operator=</a>(<a class="code" href="structGPUMemory.html">GPUMemory</a> <span class="keyword">const</span>&amp;o);</div>
<div class="line">};</div>
</div><!-- fragment --><p> <a class="el" href="structProgram.html" title="[VertexArray]">Program</a> je opět struktura: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structProgram.html">Program</a>{</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a61e7df3fcaa53829be20be29b197e3e6">VertexShader</a>   <a class="code" href="structProgram.html#a2bcea678985527f04a87be358ff1f78b">vertexShader</a>   = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#ac2dd95ee5e44978647da13fc95b9420e">FragmentShader</a> <a class="code" href="structProgram.html#a5faf623d0af27d6000ebcacafecf2eb5">fragmentShader</a> = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#addfd10ead04eeadec78064481a4a3f4d">AttributeType</a>  <a class="code" href="structProgram.html#a5b48bbf6bc459552b066757369a0f86d">vs2fs</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>] = {<a class="code" href="fwd_8hpp.html#addfd10ead04eeadec78064481a4a3f4daba2b45bdc11e2a4a6e86aab2ac693cbb">AttributeType::EMPTY</a>}; </div>
<div class="line">};</div>
</div><!-- fragment --><p> Struktura programu obsahuje vertex shader. Vertex shader je v ukazatel na funkci. Na normální GPU se jedná o program (třeba v GLSL), který se kompiluje. V projektu je to normální C/C++ funkce, která je uložena v ukazateli na funkci. Vertex shader bere 3 parametry </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="fwd_8hpp.html#a61e7df3fcaa53829be20be29b197e3e6">VertexShader</a> = void(*)(</div>
<div class="line">    <a class="code" href="structOutVertex.html">OutVertex</a>            &amp;outVertex,</div>
<div class="line">    <a class="code" href="structInVertex.html">InVertex</a>        <span class="keyword">const</span>&amp;inVertex ,</div>
<div class="line">    <a class="code" href="structShaderInterface.html">ShaderInterface</a> <span class="keyword">const</span>&amp;si       );</div>
</div><!-- fragment --><p> V tomto testu se neřeší, co dostane, ale měl by něco dostat.</p>
<h3><a class="anchor" id="drawIdPractice"></a>
Testy 7-8 - číslování kreslících příkazů - gl_DrawID</h3>
<div class="fragment"><div class="line">./izgProject -c --test 7</div>
<div class="line">./izgProject -c --test 8</div>
</div><!-- fragment --><p> Jelikož může command buffer obsahovat vícero kreslících příkazů, je nutné je číslovat. Toto číslování se používá pro výběr materiálů, textur, modelových matic a podobně. Číslují se jen vykreslovací příkazy a to pomocí čísla gl_DrawID. Toto číslo je součastí struktury <a class="el" href="structShaderInterface.html" title="[IndexType]">ShaderInterface</a>: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structShaderInterface.html">ShaderInterface</a>{</div>
<div class="line">  <a class="code" href="unionUniform.html">Uniform</a> <span class="keyword">const</span>*<a class="code" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>  = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="structTexture.html">Texture</a> <span class="keyword">const</span>*<a class="code" href="structShaderInterface.html#ad33e6e9e4ff2fbf3853b4430f05188cb">textures</a>  = <span class="keyword">nullptr</span>; </div>
<div class="line">  uint32_t      <a class="code" href="structShaderInterface.html#acdb2c4b2df7bd9535ddde723b86eabc7">gl_DrawID</a> = 0      ; </div>
<div class="line">};</div>
</div><!-- fragment --><p> ve které je položka <a class="el" href="structShaderInterface.html#acdb2c4b2df7bd9535ddde723b86eabc7">ShaderInterface::gl_DrawID</a>, což je číslo vykreslovacího příkazu, které musíte správně nastavit. Kreslící příkazy v command bufferu by měly dostat čísla 0,1,2,...<br  />
 Pokud je mezi kreslícími jiný příkaz, neovlivní to číslování. Výjimkou je příkaz <a class="el" href="structSetDrawIdCommand.html">SetDrawIdCommand</a>, který umožňuje explicitně gl_DrawID nastavit. </p><div class="image">
<object type="image/svg+xml" data="gl_DrawID.svg" width="600" style="pointer-events: none;"></object>
<div class="caption">
Pouze kreslící příkazy jsou číslovány. SetDrawId může explicitně nastasvit číslo příkazu. Je jedno, zda jsou příkazy součástí SubCommand, číslování to neovlivní.</div></div>
<p> Hrubý pseudokód může vypadat nějak takto: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> draw(<a class="code" href="structGPUMemory.html">GPUMemory</a>&amp;mem,<a class="code" href="structDrawCommand.html">DrawCommand</a> cmd){</div>
<div class="line">  <span class="comment">// výběr programu</span></div>
<div class="line">  <a class="code" href="structProgram.html">Program</a> prg = mem.<a class="code" href="structGPUMemory.html#a50091de928f20fa9d84c6bd137dab3a6">programs</a>[mem.<a class="code" href="structGPUMemory.html#a7b289e72424eb0cf9b7aa920386f7565">activatedProgram</a>];</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(every vertex v &lt; cmd.<a class="code" href="structDrawCommand.html#a4a7376486faf9f07fccb7de82d86566b">nofVertices</a>){</div>
<div class="line">    <a class="code" href="structInVertex.html">InVertex</a> inVertex;</div>
<div class="line">    <a class="code" href="structOutVertex.html">OutVertex</a> outVertex;</div>
<div class="line">    <a class="code" href="structShaderInterface.html">ShaderInterface</a> si;</div>
<div class="line">    si.<a class="code" href="structShaderInterface.html#acdb2c4b2df7bd9535ddde723b86eabc7">gl_DrawID</a> = mem.<a class="code" href="structGPUMemory.html#aa6541055bfd7af94a91f35bfe0cd9aad">gl_DrawID</a>;</div>
<div class="line">    <span class="comment">// spuštění vertex shaderu</span></div>
<div class="line">    prg.<a class="code" href="structProgram.html#a2bcea678985527f04a87be358ff1f78b">vertexShader</a>(outVertex,inVertex,si);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="gpu_8cpp.html#a534f9ebe20a4f57bd73b4dfb9bb4b29b">izg_enqueue</a>(<a class="code" href="structGPUMemory.html">GPUMemory</a>&amp;mem,<a class="code" href="structCommandBuffer.html">CommandBuffer</a> <span class="keyword">const</span>&amp;cb){</div>
<div class="line">  <span class="comment">// smyčka přes příkazy</span></div>
<div class="line">  <span class="keywordflow">for</span>(... commands ...){</div>
<div class="line">    <span class="comment">// vykreslovací příkaz</span></div>
<div class="line">    <span class="keywordflow">if</span> (commandType == <a class="code" href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352a2b4807f24940ca2fe73284bc6e864d66">CommandType::DRAW</a> ){</div>
<div class="line">      <span class="comment">// kresli</span></div>
<div class="line">      draw(mem, drawCommand);</div>
<div class="line">      <span class="comment">// počítadlo kreslících příkazů</span></div>
<div class="line">      mem.<a class="code" href="structGPUMemory.html#aa6541055bfd7af94a91f35bfe0cd9aad">gl_DrawID</a>++;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (commandType == <a class="code" href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352af33727905f5b6f48cac50cb735ed9524">CommandType::SET_DRAW_ID</a>){</div>
<div class="line">      mem.<a class="code" href="structGPUMemory.html#aa6541055bfd7af94a91f35bfe0cd9aad">gl_DrawID</a> = ...</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
</div><!-- fragment --><h3><a class="anchor" id="subCmdPractice"></a>
Testy 9-10 - sub command a mix příkazů</h3>
<p>Testy: </p><div class="fragment"><div class="line">./izgProject -c --test 9</div>
<div class="line">./izgProject -c --test 10</div>
</div><!-- fragment --><p> Sub command je způsob, jak rozšiřovat a větvit command buffer. Sub command obsahuje ukazatel na další command buffer. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structSubCommand.html">SubCommand</a>{</div>
<div class="line">  <a class="code" href="structCommandBuffer.html">CommandBuffer</a>*<a class="code" href="structSubCommand.html#a6743a1b924763618d8c2fafd3b4decd5">commandBuffer</a> = <span class="keyword">nullptr</span>; </div>
<div class="line">};</div>
</div><!-- fragment --><p> Koncept je podobný jako u sekundárních command bufferů ve Vulkánu: <a href="https://docs.vulkan.org/spec/latest/chapters/cmdbuffers.html#commandbuffers-secondary">Sekundární Command Buffer</a>. Příkladem využití <a class="el" href="structSubCommand.html">SubCommand</a> v tomto projektu je vykreslování stínů. Technika vykreslování stínů vyžaduje vykreslit scénu 2x, pokaždé s jiným programem a framebufferem. Je tak možné uložit si command buffer pro vykreslení scény a ten pak dvakrát použít v sub commandu celého snímku.</p>
<h2><a class="anchor" id="VertexAssembly"></a>
4. Úkol - Kreslení - číslování vrcholů a vertex assembly jednotka</h2>
<p>Testy: </p><div class="fragment"><div class="line">./izgProject -c --test 16 --up-to-test</div>
</div><!-- fragment --><p> Další částí úkolů je zprovoznění číslování vrcholů a vertex assembly jednotky.</p>
<h3><a class="anchor" id="gl_VertexID"></a>
Test 11 - Číslování vrcholů</h3>
<div class="fragment"><div class="line">./izgProject -c --test 11</div>
</div><!-- fragment --><p> Obdobně jako číslování kreslících příkazů, existuje i číslování vrcholů. V tomto testu musíte správně číslovat vstupní vrcholy do vertex shaderu. Zatím bude stačit pořadové číslo. Vstupní vrchol se nachází ve struktuře <a class="el" href="structInVertex.html" title="[Attribute]">InVertex</a> </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structInVertex.html">InVertex</a>{</div>
<div class="line">  <a class="code" href="unionAttribute.html">Attribute</a> <a class="code" href="structInVertex.html#a4fc269d49110daa41aedf9b8f313f0ca">attributes</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>]    ; </div>
<div class="line">  uint32_t  <a class="code" href="structInVertex.html#aa4d31911053492bffe4b41dae12ee000">gl_VertexID</a>               = 0; </div>
<div class="line">};</div>
</div><!-- fragment --><p> ve které je položka <a class="el" href="structInVertex.html#aa4d31911053492bffe4b41dae12ee000">InVertex::gl_VertexID</a>, což je číslo vrcholu, kterou musíte správně nastavit.</p>
<h3><a class="anchor" id="gl_VertexIDIndex32"></a>
Test 12 - Číslování vrcholů s indexováním.</h3>
<div class="fragment"><div class="line">./izgProject -c --test 12</div>
</div><!-- fragment --><p> V tomto testu musíte správně číslovat vstupní vrcholy, když je zapnuté indexování.<br  />
 <b>Indexované kreslení</b> je způsob snížení redundance dat s využitím indexů na vrcholy. </p><div class="image">
<object type="image/svg+xml" data="drawElements.svg" style="pointer-events: none;"></object>
<div class="caption">
Neindexované a indexované kreslení.</div></div>
<p>U neindexovaného kreslení je číslo vrcholu <a class="el" href="structInVertex.html#aa4d31911053492bffe4b41dae12ee000">InVertex::gl_VertexID</a> rovno číslu invokace vertex shaderu. U indexovaného kreslení je číslo vrcholu <a class="el" href="structInVertex.html#aa4d31911053492bffe4b41dae12ee000">InVertex::gl_VertexID</a> rovno hodnodě z indexačního bufferu. Hodnota z indexačního bufferu je vybrána číslem invokace vertex shaderu. <br  />
 Indexování může být zapnuto nebo vypnuto - o tom rozhoduje vykresovací příkaz: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structDrawCommand.html">DrawCommand</a>{</div>
<div class="line">  uint32_t    <a class="code" href="structDrawCommand.html#a4a7376486faf9f07fccb7de82d86566b">nofVertices</a>     = 0    ; </div>
<div class="line">  <span class="keywordtype">bool</span>        <a class="code" href="structDrawCommand.html#aff1a6f40fd082c3a0065b5fa3998a753">backfaceCulling</a> = <span class="keyword">false</span>; </div>
<div class="line">};</div>
</div><!-- fragment --><p> V paměti grafické karty je pole vertex array objektů <a class="el" href="structGPUMemory.html#acab4bb492d24e78131d39ea7997266cb">GPUMemory::vertexArrays</a>. Každý vertex array je tabulka nastavení takzvané vertex assembly jednotky. Struktura <a class="el" href="structVertexArray.html" title="[VertexAttrib]">VertexArray</a> vypadá následnovně: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structVertexArray.html">VertexArray</a>{</div>
<div class="line">  <a class="code" href="structVertexAttrib.html">VertexAttrib</a> <a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>];       </div>
<div class="line">  int32_t      <a class="code" href="structVertexArray.html#a7648ec169177dbb70b495b51ffcfb606">indexBufferID</a> = -1;                </div>
<div class="line">  uint64_t     <a class="code" href="structVertexArray.html#a89b9faa058891874f5bf63064deafe99">indexOffset</a>   = 0 ;                </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a862161defe984b09e24dfec9e0540a3e">IndexType</a>    <a class="code" href="structVertexArray.html#a7822420a93f7334ffdb1a0992de59ae3">indexType</a>     = <a class="code" href="fwd_8hpp.html#a862161defe984b09e24dfec9e0540a3ea17266551181f69a1b4a3ad5c9e270afc">IndexType::UINT32</a>; </div>
<div class="line">};</div>
</div><!-- fragment --><p> V této struktuře jsou pro indexovaní podstatné položky <a class="el" href="structVertexArray.html#a7648ec169177dbb70b495b51ffcfb606">VertexArray::indexBufferID</a>, <a class="el" href="structVertexArray.html#a89b9faa058891874f5bf63064deafe99">VertexArray::indexOffset</a> a <a class="el" href="structVertexArray.html#a7822420a93f7334ffdb1a0992de59ae3">VertexArray::indexType</a>. indexBufferID je číslo bufferu nebo -1 pokud je indexing vypnutý. indexOffset je posun v bajtech od začátku bufferu, kde se nacházejí indexy. indexType je typ indexu.<br  />
 Všechny buffery (stejně jako programy) se nachází v paměti grafické karty (<a class="el" href="structGPUMemory.html" title="[Buffer]">GPUMemory</a>). </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structGPUMemory.html">GPUMemory</a>{</div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#aa73d331b9be494e550928fad4ac6c23d">maxUniforms</a>          = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#a3798310241309de18f5561931d1d2665">maxVertexArrays</a>      = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#a8fa73be85fde25818e8b63d71fd7dd60">maxTextures</a>          = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#a0be973077c6d15f40e31d0781b1ea8e6">maxBuffers</a>           = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#aa8e57983bda33e4ef48e825d5bf261eb">maxPrograms</a>          = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#ad9cda42fea22fb0d5347a91f101d15d2">maxFramebuffers</a>      = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#a7f32178fb1950dde77a2133bb93bbe5b">defaultFramebuffer</a>   = 0      ; </div>
<div class="line">  <a class="code" href="structBuffer.html">Buffer</a>      *<a class="code" href="structGPUMemory.html#a4755d327262c8020766718bb31f92d0b">buffers</a>              = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="structTexture.html">Texture</a>     *<a class="code" href="structGPUMemory.html#ac07704dd918f18a48644abdabbdf6f0d">textures</a>             = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="unionUniform.html">Uniform</a>     *<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>             = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="structProgram.html">Program</a>     *<a class="code" href="structGPUMemory.html#a50091de928f20fa9d84c6bd137dab3a6">programs</a>             = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="structFramebuffer.html">Framebuffer</a> *<a class="code" href="structGPUMemory.html#abd0d80589104a936db46ae766bc7975e">framebuffers</a>         = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="structVertexArray.html">VertexArray</a> *<a class="code" href="structGPUMemory.html#acab4bb492d24e78131d39ea7997266cb">vertexArrays</a>         = <span class="keyword">nullptr</span>; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#acd06344c1c43bef8df606d6664fee4b4">activatedFramebuffer</a> = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#a7b289e72424eb0cf9b7aa920386f7565">activatedProgram</a>     = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#af2f8e1efb9217022ced48eeb04b79810">activatedVertexArray</a> = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#aa6541055bfd7af94a91f35bfe0cd9aad">gl_DrawID</a>            = 0      ; </div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Do not worry about these.</span></div>
<div class="line">  <span class="comment">//This is just to suppress valgrind warnings because of the large stack.</span></div>
<div class="line">  <span class="comment">//Otherwise everything would be placed on the stack and not on the heap.</span></div>
<div class="line">  <span class="comment">//I had to allocated this structure on the heap, because it is too large.</span></div>
<div class="line">  <a class="code" href="structGPUMemory.html#a9b333f6f69347068f349d05961c7bf39">GPUMemory</a>();                 </div>
<div class="line">  <a class="code" href="structGPUMemory.html#a9b333f6f69347068f349d05961c7bf39">GPUMemory</a>(<a class="code" href="structGPUMemory.html">GPUMemory</a> <span class="keyword">const</span>&amp;o);</div>
<div class="line">  <a class="code" href="structGPUMemory.html#aba0548cad16f8557782a5b2a409685b0">~GPUMemory</a>();                </div>
<div class="line">  <a class="code" href="structGPUMemory.html">GPUMemory</a>&amp;<a class="code" href="structGPUMemory.html#a59c169462c028204dfca9b92f5cd9230">operator=</a>(<a class="code" href="structGPUMemory.html">GPUMemory</a> <span class="keyword">const</span>&amp;o);</div>
<div class="line">};</div>
</div><!-- fragment --><p> <a class="el" href="structBuffer.html" title="[Framebuffer]">Buffer</a> je lineární paměť, reprezentovano strukturou: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structBuffer.html">Buffer</a>{</div>
<div class="line">  <span class="keywordtype">void</span> <span class="keyword">const</span>* <a class="code" href="structBuffer.html#a8fbe8b3fba53c8ff7fcd44f9c4f463c7">data</a> = <span class="keyword">nullptr</span>; </div>
<div class="line">  uint64_t    <a class="code" href="structBuffer.html#a3d37b3ab0942c1222347f8de7520f9ef">size</a> = 0      ; </div>
<div class="line">};</div>
</div><!-- fragment --><p> Indexační buffer může mít růzou velikost indexu - 8bit, 16bit a 32bit: </p><div class="fragment"><div class="line"><span class="keyword">enum class</span> <a class="code" href="fwd_8hpp.html#a862161defe984b09e24dfec9e0540a3e">IndexType</a> : uint8_t{</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a862161defe984b09e24dfec9e0540a3eaecfc091ed2a607335524c8389cfa41b5">UINT8</a>  = 1, </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a862161defe984b09e24dfec9e0540a3ea48d8f1a723d44ff4a87db1bb6c551c62">UINT16</a> = 2, </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a862161defe984b09e24dfec9e0540a3ea17266551181f69a1b4a3ad5c9e270afc">UINT32</a> = 4, </div>
<div class="line">};</div>
</div><!-- fragment --><p> Pokud je zapnuto indexování, pak je číslo vrcholu dáno položkou v indexačním bufferu, kde je položka (index) v bufferu vybrána na základě čísla invokace vertex shaderu.</p>
<h3><a class="anchor" id="VSUniforms"></a>
Test 13 - Vertex shader by měl dostat konstanty z paměti.</h3>
<div class="fragment"><div class="line">./izgProject -c --test 13</div>
</div><!-- fragment --><p> Uniformní proměnné a textury jsou z pohledu vertex shaderu konstanty. Jsou to data, která uživatel dodal svému vertex shaderu. Obvykle jsou to matice, pozice světla, barva materiálu... Všechny uniformní proměnné a textury jsou uloženy v paměti grafické karty (<a class="el" href="structGPUMemory.html" title="[Buffer]">GPUMemory</a>). </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structGPUMemory.html">GPUMemory</a>{</div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#aa73d331b9be494e550928fad4ac6c23d">maxUniforms</a>          = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#a3798310241309de18f5561931d1d2665">maxVertexArrays</a>      = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#a8fa73be85fde25818e8b63d71fd7dd60">maxTextures</a>          = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#a0be973077c6d15f40e31d0781b1ea8e6">maxBuffers</a>           = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#aa8e57983bda33e4ef48e825d5bf261eb">maxPrograms</a>          = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#ad9cda42fea22fb0d5347a91f101d15d2">maxFramebuffers</a>      = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#a7f32178fb1950dde77a2133bb93bbe5b">defaultFramebuffer</a>   = 0      ; </div>
<div class="line">  <a class="code" href="structBuffer.html">Buffer</a>      *<a class="code" href="structGPUMemory.html#a4755d327262c8020766718bb31f92d0b">buffers</a>              = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="structTexture.html">Texture</a>     *<a class="code" href="structGPUMemory.html#ac07704dd918f18a48644abdabbdf6f0d">textures</a>             = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="unionUniform.html">Uniform</a>     *<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>             = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="structProgram.html">Program</a>     *<a class="code" href="structGPUMemory.html#a50091de928f20fa9d84c6bd137dab3a6">programs</a>             = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="structFramebuffer.html">Framebuffer</a> *<a class="code" href="structGPUMemory.html#abd0d80589104a936db46ae766bc7975e">framebuffers</a>         = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="structVertexArray.html">VertexArray</a> *<a class="code" href="structGPUMemory.html#acab4bb492d24e78131d39ea7997266cb">vertexArrays</a>         = <span class="keyword">nullptr</span>; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#acd06344c1c43bef8df606d6664fee4b4">activatedFramebuffer</a> = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#a7b289e72424eb0cf9b7aa920386f7565">activatedProgram</a>     = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#af2f8e1efb9217022ced48eeb04b79810">activatedVertexArray</a> = 0      ; </div>
<div class="line">  uint32_t     <a class="code" href="structGPUMemory.html#aa6541055bfd7af94a91f35bfe0cd9aad">gl_DrawID</a>            = 0      ; </div>
<div class="line"> </div>
<div class="line">  <span class="comment">//Do not worry about these.</span></div>
<div class="line">  <span class="comment">//This is just to suppress valgrind warnings because of the large stack.</span></div>
<div class="line">  <span class="comment">//Otherwise everything would be placed on the stack and not on the heap.</span></div>
<div class="line">  <span class="comment">//I had to allocated this structure on the heap, because it is too large.</span></div>
<div class="line">  <a class="code" href="structGPUMemory.html#a9b333f6f69347068f349d05961c7bf39">GPUMemory</a>();                 </div>
<div class="line">  <a class="code" href="structGPUMemory.html#a9b333f6f69347068f349d05961c7bf39">GPUMemory</a>(<a class="code" href="structGPUMemory.html">GPUMemory</a> <span class="keyword">const</span>&amp;o);</div>
<div class="line">  <a class="code" href="structGPUMemory.html#aba0548cad16f8557782a5b2a409685b0">~GPUMemory</a>();                </div>
<div class="line">  <a class="code" href="structGPUMemory.html">GPUMemory</a>&amp;<a class="code" href="structGPUMemory.html#a59c169462c028204dfca9b92f5cd9230">operator=</a>(<a class="code" href="structGPUMemory.html">GPUMemory</a> <span class="keyword">const</span>&amp;o);</div>
<div class="line">};</div>
</div><!-- fragment --><p> Vertex Shader má kromě vrcholů <a class="el" href="structInVertex.html" title="[Attribute]">InVertex</a> a <a class="el" href="structOutVertex.html" title="[InVertex]">OutVertex</a> i vstup <a class="el" href="structShaderInterface.html">ShaderInterface</a> </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="fwd_8hpp.html#a61e7df3fcaa53829be20be29b197e3e6">VertexShader</a> = void(*)(</div>
<div class="line">    <a class="code" href="structOutVertex.html">OutVertex</a>            &amp;outVertex,</div>
<div class="line">    <a class="code" href="structInVertex.html">InVertex</a>        <span class="keyword">const</span>&amp;inVertex ,</div>
<div class="line">    <a class="code" href="structShaderInterface.html">ShaderInterface</a> <span class="keyword">const</span>&amp;si       );</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structShaderInterface.html">ShaderInterface</a>{</div>
<div class="line">  <a class="code" href="unionUniform.html">Uniform</a> <span class="keyword">const</span>*<a class="code" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>  = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="structTexture.html">Texture</a> <span class="keyword">const</span>*<a class="code" href="structShaderInterface.html#ad33e6e9e4ff2fbf3853b4430f05188cb">textures</a>  = <span class="keyword">nullptr</span>; </div>
<div class="line">  uint32_t      <a class="code" href="structShaderInterface.html#acdb2c4b2df7bd9535ddde723b86eabc7">gl_DrawID</a> = 0      ; </div>
<div class="line">};</div>
</div><!-- fragment --><p> Struktura <a class="el" href="structShaderInterface.html" title="[IndexType]">ShaderInterface</a> jednoduše odkazuje na tabulky uniformních proměnných a textur.</p>
<h3><a class="anchor" id="VertexPuller_Att"></a>
Testy 14-16 - Vertex Atributy, Vertex Assembly jednotka</h3>
<div class="fragment"><div class="line">./izgProject -c --test 14</div>
<div class="line">./izgProject -c --test 15</div>
<div class="line">./izgProject -c --test 16</div>
</div><!-- fragment --><p> V tomto testu musíte naprogramovat funkcionalitu Vertex Assembly jednotky.<br  />
 <b>Vertex Assembly</b> (nebo taky Vertex Puller, Vertex Specification, ...) je zařízení na grafické kartě, které se stará o sestavení vrcholů. </p><div class="image">
<object type="image/svg+xml" data="vertexAssembly.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Vertex Assembly jednotka sestavuje vrcholy z paměti (většinou). K tomu potřebuje tabulka nastavení (VertexArray) a číslo vrcholu.</div></div>
<p> Vertex není jen bod v prostoru. Vertex je uživatelem specifikovaná struktura. Uživatel může mít po vrcholech různé požadavky a tak do vrcholů může přidat různé množství attributů &ndash; vertex attributů. Kromě uživatelem specifikovaných atributů, obsahují i pevně vestavěné atributy (gl_VertexID a další). </p><div class="image">
<object type="image/svg+xml" data="vertex.svg" width="900" style="pointer-events: none;"></object>
<div class="caption">
Vrchol je struktura dat. Ve struktuře jsou vertex attributy. Ty mívají uživatelem specifikovaný význam (třeba pozice, normála, ...). Vertex Assembly sestavuje InVertex, který je poslán jako vstup do vertex shaderu. OutVertex je výstup vertex shaderu.</div></div>
<p> Sestavené vcholy jsou posílány do vertex shaderu pro zpracování uživetelem definovaným kódem. Vertex shader transformuje vrcholy maticemi a vypočítává výstupní vrcholy. </p><div class="image">
<object type="image/svg+xml" data="vertexInOut.svg" width="400" style="pointer-events: none;"></object>
<div class="caption">
Jsou dva typy vrcholů. Ty, které sestavuje jednotka Vertex Assembly a vstupují do vertex shaderu. A ty, které jsou výstupem vertex shaderu.</div></div>
<p> Vrchol (<a class="el" href="structInVertex.html">InVertex</a>) je složen z <a class="el" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a> vertex attributů, každý může být různého typu (<a class="el" href="fwd_8hpp.html#addfd10ead04eeadec78064481a4a3f4d">AttributeType</a> (float, vec2, vec3, vec4, ...) a čísla vrcholu <a class="el" href="structInVertex.html#aa4d31911053492bffe4b41dae12ee000">InVertex::gl_VertexID</a>.<br  />
 Struckura <a class="el" href="structInVertex.html">InVertex</a> vypadá takto: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structInVertex.html">InVertex</a>{</div>
<div class="line">  <a class="code" href="unionAttribute.html">Attribute</a> <a class="code" href="structInVertex.html#a4fc269d49110daa41aedf9b8f313f0ca">attributes</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>]    ; </div>
<div class="line">  uint32_t  <a class="code" href="structInVertex.html#aa4d31911053492bffe4b41dae12ee000">gl_VertexID</a>               = 0; </div>
<div class="line">};</div>
</div><!-- fragment --><p> Struktura <a class="el" href="structOutVertex.html">OutVertex</a> vypadá takto: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structOutVertex.html">OutVertex</a>{</div>
<div class="line">  <a class="code" href="unionAttribute.html">Attribute</a> <a class="code" href="structOutVertex.html#ad1d48203a36e3ee510841f25a5bc068e">attributes</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>]                     ; </div>
<div class="line">  glm::vec4 <a class="code" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a>               = glm::vec4(0,0,0,1); </div>
<div class="line">};</div>
</div><!-- fragment --><p> Obě struktury obsahují vertex atributy <a class="el" href="unionAttribute.html">Attribute</a> </p><div class="fragment"><div class="line"><span class="keyword">union </span><a class="code" href="unionAttribute.html">Attribute</a>{</div>
<div class="line">  <a class="code" href="unionAttribute.html">Attribute</a>():<a class="code" href="unionAttribute.html#ac47131c7c30814e28f0c4662a4ed2737">v4</a>(glm::vec4(1.f)){}</div>
<div class="line">  <span class="keywordtype">float</span>      <a class="code" href="unionAttribute.html#a2a9e03282539207b21a9b61596e6b72c">v1</a>; </div>
<div class="line">  glm::vec2  <a class="code" href="unionAttribute.html#aa240c263ec02c39b48d662a1c598e1fc">v2</a>; </div>
<div class="line">  glm::vec3  <a class="code" href="unionAttribute.html#a7e4149eff36adcf056cb7153bfbf4c8c">v3</a>; </div>
<div class="line">  glm::vec4  <a class="code" href="unionAttribute.html#ac47131c7c30814e28f0c4662a4ed2737">v4</a>; </div>
<div class="line">  uint32_t   <a class="code" href="unionAttribute.html#a63c701e46c9ce4fb0e9494806769faa1">u1</a>; </div>
<div class="line">  glm::uvec2 <a class="code" href="unionAttribute.html#a179957a4d2f0939276694bd8db6aecd1">u2</a>; </div>
<div class="line">  glm::uvec3 <a class="code" href="unionAttribute.html#af2690c24c27269bea60eb0dff02c6861">u3</a>; </div>
<div class="line">  glm::uvec4 <a class="code" href="unionAttribute.html#a9ccf454d347d4fabf4e89207f01812b1">u4</a>; </div>
<div class="line">};</div>
</div><!-- fragment --><p> Vertex Assembly jednotka se řídí podle nastavení ze struktury <a class="el" href="structVertexArray.html" title="[VertexAttrib]">VertexArray</a>. </p><div class="image">
<object type="image/svg+xml" data="pullerSettings.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Nastavení pro Vertex Assembly jednotku - VertexArray.</div></div>
<p> Toto nastavení je uloženo ve struktuře <a class="el" href="structVertexArray.html" title="[VertexAttrib]">VertexArray</a>: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structVertexArray.html">VertexArray</a>{</div>
<div class="line">  <a class="code" href="structVertexAttrib.html">VertexAttrib</a> <a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>];       </div>
<div class="line">  int32_t      <a class="code" href="structVertexArray.html#a7648ec169177dbb70b495b51ffcfb606">indexBufferID</a> = -1;                </div>
<div class="line">  uint64_t     <a class="code" href="structVertexArray.html#a89b9faa058891874f5bf63064deafe99">indexOffset</a>   = 0 ;                </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a862161defe984b09e24dfec9e0540a3e">IndexType</a>    <a class="code" href="structVertexArray.html#a7822420a93f7334ffdb1a0992de59ae3">indexType</a>     = <a class="code" href="fwd_8hpp.html#a862161defe984b09e24dfec9e0540a3ea17266551181f69a1b4a3ad5c9e270afc">IndexType::UINT32</a>; </div>
<div class="line">};</div>
</div><!-- fragment --><p> Je složeno z nastavení pro indexování a nastavení pro vertex attributy. <a class="el" href="structVertexAttrib.html" title="[FragmentShader]">VertexAttrib</a> je struktura obsahují nastavení, jak číst jeden Vertex Attribut. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structVertexAttrib.html">VertexAttrib</a>{</div>
<div class="line">  int32_t       <a class="code" href="structVertexAttrib.html#a4578d3605e0f61b7bfd1f5e24df7c9bf">bufferID</a> = -1                  ;</div>
<div class="line">  uint64_t      <a class="code" href="structVertexAttrib.html#aef250d71bce43e96a6efb9180f24d079">stride</a>   = 0                   ;</div>
<div class="line">  uint64_t      <a class="code" href="structVertexAttrib.html#a58f3129f893d0ce72ec7d364fef21840">offset</a>   = 0                   ;</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#addfd10ead04eeadec78064481a4a3f4d">AttributeType</a> <a class="code" href="structVertexAttrib.html#a0b722b51b4528b50603e99722329d41a">type</a>     = <a class="code" href="fwd_8hpp.html#addfd10ead04eeadec78064481a4a3f4daba2b45bdc11e2a4a6e86aab2ac693cbb">AttributeType::EMPTY</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Vertex Assembly jednotka je složena z <a class="el" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a> čtecích hlav, které sestavují jednotlivé vertex attributy. <a class="el" href="structInVertex.html">InVertex</a> je složen z <a class="el" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a> atributů, každý odpovídá jedné čtecí hlavě z Vertex Assembly jednotky. Čtecí hlava obsahuje nastavení - offset, stride, type a buffer. Pokud je čtecí hlava povolena (typ není empty), měla by zkopírovat data (o velikosti vertex atributu) z bufferu od daného offsetu, s krokem stride. Všechny velikosti jsou v bajtech. Krok se použije při čtení různých vrcholů: atributy by měly být čteny z adresy: buf_ptr + offset + stride*gl_VertexID <br  />
 Na dalších dvou obrázcích je příklad stavu Vertex Assembly jednotky ve dvou (0. a 1.) invokaci vertex shaderu. </p><div class="image">
<object type="image/svg+xml" data="puller0.svg" style="pointer-events: none;"></object>
<div class="caption">
příklad vertex pulleru při 0. invokací vertex shaderu. Vertex je složen z 3 vertex atributů (coord, normal, position). Čtecí hlavy začínají na daných offsetech a v daných bufferech.</div></div>
 <div class="image">
<object type="image/svg+xml" data="puller1.svg" style="pointer-events: none;"></object>
<div class="caption">
příklad vertex pulleru při 1. invokací vertex shaderu. Čtecí hlavy se posunuly o krok (stride).</div></div>
<p>Po těchto úkolech byste měli mít hotovotou část před vertex shaderem.</p>
<h2><a class="anchor" id="Raster"></a>
5. Úkol - naprogramovat Primitive Assembly jednotku, rasterizaci a pouštění fragment shaderu</h2>
<p>V tomto úkolu je potřeba rozšířit funkcionalitu funkce izg_enqueue o schopnosti rasterizace. Cílem je naprogramovat části zobrazovacího řetězce, které jsou za vertex shaderem po rasterizaci a pouštění fragment shaderu (včetně).<br  />
 Jedná se o testy 17. - 22.<br  />
 </p>
<h3><a class="anchor" id="rasterPractice"></a>
Teorie</h3>
<p>Vertex Assembly jednotka chrlí vrcholy a vertex shader je zpracovává, transformuje. Je na čase z nich sestavit trojúhelníky a připravit je pro rasterizaci. Část za vertex shaderem je složena z několika částí. </p><div class="image">
<object type="image/svg+xml" data="pipeline_after_vs.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Část za vertex shaderem je složena z několika jednotek. Je to jednotka sestavení primitiv (trojúhelníků), ořez (ten teď dělat nebudete), perspektivní dělení, viewport transformace, culling. Po vektorové části následuje rasterizace a fragment shader</div></div>
 <h3>Primitive Assembly</h3>
<p>Primitive Assembly je jednotka, která sestavuje trojúhelníky (mimo jiné). Trojúhelníku, úsečce, bodu se hromadně říká primitivum. V tomto projektu se používají pouze trojúhelníky. Primitive Assembly jednotka si počká na 3 po sobě jdoucí <a class="el" href="structOutVertex.html">výstupní vrcholy</a> z vertex shaderu a sestaví trojúhelník (struktura, která by měla obsahovat 3 výstupní vrcholy). Lze na to také nahlížet tak, že primitive assembly jednotka dostane příkaz vykreslit třeba 4 trojúhelníky. Jednotka tak spustí vertex shader 12x, který takto spustí 12x vertex assembly jednotku.</p>
<div class="image">
<object type="image/svg+xml" data="PrimitiveAssembly.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Vizualizace funkce primitive assembly jednotky. Primitive assembly jednotka sestaví trojúhelník ze 3 po sobě jdoucích výstupních vrcholů z vertex shaderu.</div></div>
<h3>Perspektivní dělení</h3>
<p>Perspektivní dělení následuje za clippingem (ten bude až později, teď není potřeba) a provádí převod z homogenních souřadnic na kartézské pomocí dělení w. </p><div class="image">
<object type="image/svg+xml" data="PerspectiveDivision.svg" width="500" style="pointer-events: none;"></object>
<div class="caption">
Perspektivní dělení. Převod z clip-space do NDC (normalized device coordinates). Dělí se pomocí w. Při tomto dělení vzniknou normalizované souřadnice x,y a normalizovaná hloubka.</div></div>
<h3>Viewport transformace</h3>
<p>Viewport transformace provádí převod NDC (rozsah -1, +1) na rozlišení okna, aby se mohla provést rasterizace. </p><div class="image">
<object type="image/svg+xml" data="ViewportTransformation.svg" width="500" style="pointer-events: none;"></object>
<div class="caption">
Vizualizace viewport transformace. Trojúhelníky jsou roztaženy na rozlišení obrazovky [width,height] do screen-space. Hloubka zůstane zachována v komponentě z.</div></div>
<h3>Culling / Backface Culling</h3>
<p>Backface Culling se stará o zahození trojúhelníků, které jsou odvráceny od pozorovatele. Culling lze zapnout nebo vypnout pomocí: <a class="el" href="structDrawCommand.html#aff1a6f40fd082c3a0065b5fa3998a753">DrawCommand::backfaceCulling</a>. Pokud je zapnutý, trojúhelníky, které jsou specifikovány po směru hodinových ručiček jsou zahazovány. Pokud je vypnutý, vykreslují se všechny trojúhelníky - přivrácené i odvrácené - specifikované po i proti směru hodinových ručiček. </p><div class="image">
<object type="image/svg+xml" data="backfaceCulling.svg" width="500" style="pointer-events: none;"></object>
<div class="caption">
Levý trojúhelník je specifikovaný proti směru hodinových ručiček (counter clock wise) a je přivrácený k pozorovateli. Pravý je po směru (clock wise) a je odvrácený od uživatele. Levý se bude vždy vykreslovat, pravý pouze tehdy, pokud je back face culling vypnutý.</div></div>
<h3>Rasterizace </h3>
<p>Rasterizace rasterizuje trojúhelník ve screen-space. Rasterizace produkuje fragmenty v případě, že <b>střed</b> pixelu leží uvnitř trojúhelníka. </p><div class="image">
<object type="image/svg+xml" data="rasterization.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Rasterizace produkuje fragmenty. Pokud střed pixelu leží uvnitř trojúhelníka, vytvoří se fragment.</div></div>
<h3>Fragment processor </h3>
<p>Fragment processor spouští fragment shader nad každým fragmentem. Data pro fragment shader jsou uložena ve struktuře <a class="el" href="structInFragment.html">InFragment</a>. Výstup fragment shaderu je výstupní fragment <a class="el" href="structOutFragment.html">OutFragment</a> - barva. Další (konstantní) vstup fragment shaderu jsou uniformní proměnné a textury. </p><div class="image">
<object type="image/svg+xml" data="FragmentShader.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Vizualizace vstupů a výstupů fragment shaderu. Fragment Shader se pouší nad každým vyrasterizovaným fragmentem.</div></div>
<p>Pseudokód může po upravení vypadat nějak takto: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> runVertexAssembly(){</div>
<div class="line">  computeVertexID();</div>
<div class="line">  readAttributes();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> runPrimitiveAssembly(primitive,vertexArray,t,program){</div>
<div class="line">  <span class="keywordflow">for</span>(every vertex v in triangle){</div>
<div class="line">    <a class="code" href="structInVertex.html">InVertex</a> inVertex;</div>
<div class="line">    runVertexAssembly(inVertex,vertexArray,t+v);</div>
<div class="line">    <a class="code" href="structShaderInterface.html">ShaderInterface</a> si;</div>
<div class="line">    program.vertexShader(primitive.vertex,inVertex,si);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> rasterizeTriangle(framebuffer,primitive,prrogram){</div>
<div class="line">  <span class="keywordflow">for</span>(pixels in frame){</div>
<div class="line">    <span class="keywordflow">if</span>(pixels in primitive){</div>
<div class="line">      <a class="code" href="structInFragment.html">InFragment</a> inFragment;</div>
<div class="line">      createFragment(inFragment,primitive,barycentrics,pixelCoord,program);</div>
<div class="line">      <a class="code" href="structOutFragment.html">OutFragment</a> outFragment;</div>
<div class="line">      <a class="code" href="structShaderInterface.html">ShaderInterface</a> si;</div>
<div class="line">      program.fragmentShader(outFragment,inFragment,si);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> draw(<a class="code" href="structGPUMemory.html">GPUMemory</a>&amp;mem,<a class="code" href="structDrawCommand.html">DrawCommand</a> <span class="keyword">const</span>&amp;cmd){</div>
<div class="line">  <span class="keywordflow">for</span>(every triangle t){</div>
<div class="line">    Primitive primitive;</div>
<div class="line">    runPrimitiveAssembly(primitive,vertexArray,t,program)</div>
<div class="line"> </div>
<div class="line">    runPerspectiveDivision(primitive)</div>
<div class="line">    runViewportTransformation(primitive,width,height)</div>
<div class="line">    rasterizeTriangle(framebuffer,primitive,program);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="gpu_8cpp.html#a534f9ebe20a4f57bd73b4dfb9bb4b29b">izg_enqueue</a>(<a class="code" href="structGPUMemory.html">GPUMemory</a>&amp;mem,<a class="code" href="structCommandBuffer.html">CommandBuffer</a> <span class="keyword">const</span>&amp;cb){</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="raster_test"></a>
Test 17 - Ověření, že rasterizace produkuje fragmenty</h3>
<p>V tomto úkolu budete muset naprogramovat rasterizaci. Neobejdete se bez viewport transformace, rasterizace a zavolání fragment shaderu nad každným fragmentem. Tento test spočívá ve zkoušení vyrasterizování několika různých trojúhelníků a počítání, kolik se vyrasterizovalo fragmentů.<br  />
 Testy pustíte: </p><div class="fragment"><div class="line">izgProject -c --test 17</div>
</div><!-- fragment --><h3><a class="anchor" id="pd_test"></a>
Test 18 - Ověření, zda počítáte perspektivní dělení.</h3>
<p>Tento test ověřuje, zda provádíte perspektivní dělení. </p><div class="fragment"><div class="line">izgProject -c --test 18</div>
</div><!-- fragment --><h3><a class="anchor" id="fragCoord_test"></a>
Test 19 - Ověření, zda vyrasterizované fragmenty mají správnou 2D pozici.</h3>
<p>Tento test ověřuje, zda vyrasterizované fragmenty mají správnou 2D pozici <a class="el" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">InFragment::gl_FragCoord</a>. </p><div class="fragment"><div class="line">izgProject -c --test 19</div>
</div><!-- fragment --><p> Fragmenty mají souřadnice středů pixelů, kterým náleží. Tzn. fragment pro levý dolní pixel [0,0] má souřadnice gl_FragCoord.xy = [0.5,0.5]</p>
<h3><a class="anchor" id="depthInterp_test"></a>
Test 20 - Ověření, zda se správně interpoluje hloubka fragmentů.</h3>
<p>Tento test ověřuje, zda vyrasterizované fragmenty mají správně interpolovanou hloubku. </p><div class="fragment"><div class="line">izgProject -c --test 20</div>
</div><!-- fragment --><p> Hloubka fragmentu je v komponentě "z" položky <a class="el" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">InFragment::gl_FragCoord</a>. Pro její interpolaci potřebujete hloubky vrcholů trojúhelníka a barycentrické souřadnice fragmentu ve 2D.<br  />
 Hloubky vrcholů najdete ve "z" komponentě položky <a class="el" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">OutVertex::gl_Position</a> gl_Position.z </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structOutVertex.html">OutVertex</a>{</div>
<div class="line">  <a class="code" href="unionAttribute.html">Attribute</a> <a class="code" href="structOutVertex.html#ad1d48203a36e3ee510841f25a5bc068e">attributes</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>]                     ; </div>
<div class="line">  glm::vec4 <a class="code" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a>               = glm::vec4(0,0,0,1); </div>
<div class="line">};</div>
</div><!-- fragment --><p> Hloubku zapisujte do komponenty "z" položky <a class="el" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">InFragment::gl_FragCoord</a> gl_FragCoord.z </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structInFragment.html">InFragment</a>{</div>
<div class="line">  <a class="code" href="unionAttribute.html">Attribute</a> <a class="code" href="structInFragment.html#af9cd9e9a684a1c454d52d7e191564be1">attributes</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>]               ; </div>
<div class="line">  glm::vec4 <a class="code" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">gl_FragCoord</a>              = glm::vec4(1); </div>
<div class="line">};</div>
</div><!-- fragment --><p> Barycentrické souřadnice musíte spočítat podle obsahů: </p><div class="image">
<object type="image/svg+xml" data="barycentric2D.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Barycentrické souřadnice ve 2D jsou spočítány jako poměry obsahů podtrojúhelníků.</div></div>
<p> Hlouba se interpoluje pomocí barycentrických souřadnic ve 2D: </p><p class="formulaDsp">
\[\displaystyle fragment.gl\_FragCoord.z = vertex[0].gl\_Position.z\cdot \lambda_0^{2D} + vertex[1].gl\_Position.z\cdot \lambda_1^{2D} + vertex[2].gl\_Position.z\cdot \lambda_2^{2D}\]
</p>
<p> Hloubka vrcholů vertex[].gl_Position.z vznikla při perspektivním dělení.</p>
<h3><a class="anchor" id="attInterp_test"></a>
Testy 21-22 - Ověření, zda se správně interpolují vertex attributy.</h3>
<p>Tyto dva testy ověřují, jestli se správně interpolují vertex atributy do fragment atributů. </p><div class="fragment"><div class="line">izgProject -c --test 21</div>
<div class="line">izgProject -c --test 22</div>
</div><!-- fragment --><p> Vertex Attributy jsou se struktuře <a class="el" href="structOutVertex.html" title="[InVertex]">OutVertex</a> </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structOutVertex.html">OutVertex</a>{</div>
<div class="line">  <a class="code" href="unionAttribute.html">Attribute</a> <a class="code" href="structOutVertex.html#ad1d48203a36e3ee510841f25a5bc068e">attributes</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>]                     ; </div>
<div class="line">  glm::vec4 <a class="code" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a>               = glm::vec4(0,0,0,1); </div>
<div class="line">};</div>
</div><!-- fragment --><p> A ze tří těchto vrcholů by se měly interpolovat atributy <a class="el" href="structInFragment.html" title="[OutVertex]">InFragment</a>. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structInFragment.html">InFragment</a>{</div>
<div class="line">  <a class="code" href="unionAttribute.html">Attribute</a> <a class="code" href="structInFragment.html#af9cd9e9a684a1c454d52d7e191564be1">attributes</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>]               ; </div>
<div class="line">  glm::vec4 <a class="code" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">gl_FragCoord</a>              = glm::vec4(1); </div>
<div class="line">};</div>
</div><!-- fragment --><p> Interpolujte pouze ty atributy, které jsou poznačené v položce <a class="el" href="structProgram.html#a5b48bbf6bc459552b066757369a0f86d">Program::vs2fs</a>! A pouze ty, které nejsou typu integer! Integerové atributy neinterpolujte, ale pouze použijte hodnoty nultého vrcholu. Tomuto vrcholu se také říká provoking vertex. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structProgram.html">Program</a>{</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a61e7df3fcaa53829be20be29b197e3e6">VertexShader</a>   <a class="code" href="structProgram.html#a2bcea678985527f04a87be358ff1f78b">vertexShader</a>   = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#ac2dd95ee5e44978647da13fc95b9420e">FragmentShader</a> <a class="code" href="structProgram.html#a5faf623d0af27d6000ebcacafecf2eb5">fragmentShader</a> = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#addfd10ead04eeadec78064481a4a3f4d">AttributeType</a>  <a class="code" href="structProgram.html#a5b48bbf6bc459552b066757369a0f86d">vs2fs</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>] = {<a class="code" href="fwd_8hpp.html#addfd10ead04eeadec78064481a4a3f4daba2b45bdc11e2a4a6e86aab2ac693cbb">AttributeType::EMPTY</a>}; </div>
<div class="line">};</div>
</div><!-- fragment --><p> Atributy je potřeba interpolovat pomocí perspektivně korektně upravených barycentrických souřadnic. Perspektivně korektní interpolace: </p><p class="formulaDsp">
\[\displaystyle \frac{\frac{A_0 \cdot \lambda_0^{2D}}{h_0} + \frac{A_1 \cdot \lambda_1^{2D}}{h_1} + \frac{A_2 \cdot \lambda_2^{2D}}{h_2}}{\frac{\lambda_0^{2D}}{h_0}+\frac{\lambda_1^{2D}}{h_1}+\frac{\lambda_2^{2D}}{h_2}}\]
</p>
<p> Kde \(\lambda_0^{2D},\lambda_1^{2D},\lambda_2^{2D}\) jsou barycentrické koordináty ve 2D, \(h_0,h_1,h_2\) je homogenní složka vrcholů a \(A_0,A_1,A_2\) je atribut vrcholu.<br  />
 Homogenní složka vrcholů je čtvrtá složka - tím čím se dělilo ve perspektivním dělení: h0 = vertex[0].gl_Position.w, h1 = vertex[1].gl_Position.w, ... <br  />
 Barycentrické souřadnice je možné přepočítat na perspektivně koretní barycentrické souřadnice (je to jen přepsání zvorečku nahoře): </p><p class="formulaDsp">
\[\displaystyle s = \frac{\lambda_0^{2D}}{h_0}+\frac{\lambda_1^{2D}}{h_1}+\frac{\lambda_2^{2D}}{h_2}\]
</p>
 <p class="formulaDsp">
\[\displaystyle \lambda_0 = \frac{\lambda_0^{2D}}{h_0\cdot s}\]
</p>
 <p class="formulaDsp">
\[\displaystyle \lambda_1 = \frac{\lambda_1^{2D}}{h_1\cdot s}\]
</p>
 <p class="formulaDsp">
\[\displaystyle \lambda_2 = \frac{\lambda_2^{2D}}{h_2\cdot s}\]
</p>
<p> Ty je potom možné použít pro interpolaci atributů: </p><p class="formulaDsp">
\[\displaystyle fragment.attribute = vertex[0].attribute\cdot \lambda_0 + vertex[1].attribute\cdot \lambda_1 + vertex[2].attribute\cdot \lambda_2\]
</p>
 <div class="image">
<object type="image/svg+xml" data="interpolation.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Rasterizace a interpolace vertex atributů. Vertex Atributy jsou interpolovány pomocí perspektivně korektních barycentrických souřadnic l0,l1,l2.</div></div>
<h2><a class="anchor" id="pfo"></a>
6 Úkol - naprogramovat per fragment operace a zápis do framebufferu.</h2>
<p>Rastrovou část zobrazovacího řetězce už byla částečně nakousnutá v předcházejícím úkolu (byl volán fragment shader).</p>
<h3><a class="anchor" id="pfoTheory"></a>
Teorie</h3>
<p>Rastrová část vypadá takto: </p><div class="image">
<object type="image/svg+xml" data="pipeline_raster.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Rastrová část je složena z fragment shaderu a per fragment operací. Jsou dvě PFO operace: hloubkový test a blending. Fragmenty se poté přimíchají do framebufferu.</div></div>
<p> Mezi Per-fragment operace (PFO) patří: </p><ul>
<li>
discarding - zahazování fragmentů, </li>
<li>
hloubkový test (depth test), </li>
<li>
blending - pro průhledné objekty. </li>
</ul>
<p>PFO využívají informace z <a class="el" href="structFramebuffer.html">Framebuffer</a>, <a class="el" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">InFragment::gl_FragCoord</a>, <a class="el" href="structOutFragment.html#a9670bf5a31a5c23fccdbeaad959cc3cf">OutFragment::gl_FragColor</a>, <a class="el" href="structOutFragment.html#aa9b70f2f945e7b287321be9a1309f512">OutFragment::discard</a>. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structOutFragment.html">OutFragment</a>{</div>
<div class="line">  glm::vec4 <a class="code" href="structOutFragment.html#a9670bf5a31a5c23fccdbeaad959cc3cf">gl_FragColor</a> = glm::vec4(0.f); </div>
<div class="line">  <span class="keywordtype">bool</span>      <a class="code" href="structOutFragment.html#aa9b70f2f945e7b287321be9a1309f512">discard</a>      = false         ; </div>
<div class="line">};</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structInFragment.html">InFragment</a>{</div>
<div class="line">  <a class="code" href="unionAttribute.html">Attribute</a> <a class="code" href="structInFragment.html#af9cd9e9a684a1c454d52d7e191564be1">attributes</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>]               ; </div>
<div class="line">  glm::vec4 <a class="code" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">gl_FragCoord</a>              = glm::vec4(1); </div>
<div class="line">};</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structFramebuffer.html">Framebuffer</a>{</div>
<div class="line">  <a class="code" href="structImage.html">Image</a>    <a class="code" href="structFramebuffer.html#aaaf692c4a3881fdd17df05c0d9b0811f">color</a>            ; </div>
<div class="line">  <a class="code" href="structImage.html">Image</a>    <a class="code" href="structFramebuffer.html#ad56ef80596abe229e99657865ae8a79b">depth</a>            ; </div>
<div class="line">  uint32_t <a class="code" href="structFramebuffer.html#ad2efd3ac1249da4ce70d478cd48d0e22">width</a>     = 0    ; </div>
<div class="line">  uint32_t <a class="code" href="structFramebuffer.html#a614fd13812430c2ffb379b3b050780c4">height</a>    = 0    ; </div>
<div class="line">  <span class="keywordtype">bool</span>     <a class="code" href="structFramebuffer.html#a5227afe8482c1670d87d34cf61ec08da">yReversed</a> = <span class="keyword">false</span>; </div>
<div class="line">};</div>
</div><!-- fragment --> <h3>Discrading </h3>
<p>Operace discard neboli zahazování fragmentů fragment zahodí. V takovém případě se nezapíše ani barva ani hloubka do framebufferu. Discarding se používá hojně, například v třetím Zaklínačovi jej používají pro zprůhlednění křoví.</p>
<h3>Hloubkový test </h3>
<p>Hloubkový test je jedna z per fragment operací. Stará se o zahazování fragmentů, které jsou hlouběji než to, co už se vyrasterizovalo. Využívá k tomu hloubkový buffer. Hloubka fragmentu je "z" komponenta <a class="el" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">InFragment::gl_FragCoord</a> InFragment::gl_FragCoord.z. Pokud je hloubka nového fragment menší, je jeho barva a hloubka zapsána do framebufferu. Dejte pozor na přetečení rozsahu <a class="el" href="structOutFragment.html#a9670bf5a31a5c23fccdbeaad959cc3cf">OutFragment::gl_FragColor</a>. Před zápisem je nutné ořezat barvu do rozsahu &lt;0,1&gt; a pak převést na správný typ. </p><div class="image">
<object type="image/svg+xml" data="PFO.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Vizualizace depth testu. Starý fragment (jeho barva a hloubka) je nahrazen pokud má nový fragment menší hloubku.</div></div>
<h3>Blending </h3>
<p>Blending je PFO operace, která místo toho, aby barvu ve framebuffer přepsala novou barvou fragmentu, tak ji smíchá. Blending má v reálu mnoho nastavení, v projetku se používá pouze alpha blending.<br  />
 Fragmenty mají barvu RGBA, kde A - \(\alpha\) je tzv. neprůhlednost.<br  />
 Pokud má nový fragment \(\alpha=1\) - je absolutně neprůhledný - plně přepíše barvu ve framebufferu, když projde hloubkovým testem.<br  />
 Pokud má nový fragment \(\alpha=0\) - je absolutně průhledný - vůbec barvu ve framebuffer nezmění, i když projde hloubkovým testem.<br  />
 Pokud má hodnotu někde mezi, tak se barva lineárně smíchá: </p><p class="formulaDsp">
\[\displaystyle colorBuffer_{rgb} = colorBuffer_{rgb} \cdot (1-\alpha) + gl\_FragColor_{rgb} \cdot \alpha\]
</p>
<p> Kde \(\alpha=gl\_FragColor_a\)</p>
<p>K per fragment operacím se vážou testy 23. - 27. </p>
<h3><a class="anchor" id="pfo_test"></a>
Testy 23-27 - Per-fragment operace</h3>
<p>Tyto testy ověřují, jestli se správně provádí per fragment operace a zápis do framebufferu. </p><div class="fragment"><div class="line">izgProject -c --test 23</div>
<div class="line">izgProject -c --test 24</div>
<div class="line">izgProject -c --test 25</div>
<div class="line">izgProject -c --test 26</div>
<div class="line">izgProject -c --test 27</div>
</div><!-- fragment --><p> Upravený pseudokód funkce může vypadat takto: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> runVertexAssembly(){</div>
<div class="line">  computeVertexID()</div>
<div class="line">  readVertexAttributes();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> runPrimitiveAssembly(primitive,<a class="code" href="structVertexArray.html">VertexArray</a> vao,t,vertexShader,shaderInterface){</div>
<div class="line">  <span class="keywordflow">for</span>(every vertex v in triangle){</div>
<div class="line">    <a class="code" href="structInVertex.html">InVertex</a> inVertex;</div>
<div class="line">    runVertexAssembly(inVertex,vao,t+v);</div>
<div class="line">    vertexShader(primitive.vertex,inVertex,shaderInterface);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> rasterizeTriangle(framebuffer,primitive,fragmentShader){</div>
<div class="line">  <span class="keywordflow">for</span>(pixels in frame){</div>
<div class="line">    <span class="keywordflow">if</span>(pixels in primitive){</div>
<div class="line">      <a class="code" href="structInFragment.html">InFragment</a> inFragment;</div>
<div class="line">      createFragment(inFragment,primitive,barycentrics,pixelCoord,prg);</div>
<div class="line">      <a class="code" href="structOutFragment.html">OutFragment</a> outFragment;</div>
<div class="line">      <a class="code" href="structShaderInterface.html">ShaderInterface</a> si;</div>
<div class="line">      si.<a class="code" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a> = ...;</div>
<div class="line">      si.<a class="code" href="structShaderInterface.html#ad33e6e9e4ff2fbf3853b4430f05188cb">textures</a> = ...;</div>
<div class="line">      </div>
<div class="line">      fragmentShader(outFragment,inFragment,si);</div>
<div class="line">      clampColor(outFragment,0,1);</div>
<div class="line">      perFragmentOperations(framebuffer,outFragment,inFragment.<a class="code" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">gl_FragCoord</a>.z)</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> draw(<a class="code" href="structGPUMemory.html">GPUMemory</a>&amp;mem,<a class="code" href="structDrawCommand.html">DrawCommand</a> <span class="keyword">const</span>&amp;cmd){</div>
<div class="line">  <span class="keywordflow">for</span>(every triangle t){</div>
<div class="line">    Primitive primitive;</div>
<div class="line">    runPrimitiveAssembly(primitive,vao,t,vertexShader,shaderInterface)</div>
<div class="line"> </div>
<div class="line">    runPerspectiveDivision(primitive)</div>
<div class="line">    runViewportTransformation(primitive,width,height)</div>
<div class="line">    rasterizeTriangle(framebuffer,primitive,fragmentShader);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="gpu_8cpp.html#a534f9ebe20a4f57bd73b4dfb9bb4b29b">izg_enqueue</a>(...){</div>
<div class="line">}</div>
<div class="line"> </div>
</div><!-- fragment --><p> Pokud to všechno budete mít hotové, mělo by vám začít fungovat zobrazování. Jestli ano, gratuluji. Máte první část hotovou.<br  />
</p>
<h2><a class="anchor" id="clip"></a>
7. Úkol - naprogramovat ořez trojúhelníků blízkou ořezovou rovinou</h2>
<p>Tento úkol opravuje vykreslování pokud je geometrie za pozorovatelem.<br  />
 Tyto úkoly můžete přeskočit a vrátit se k nim později. Pokud se na geometrii budete dívat tak, že leží vždy před vámi, nepoznáte rozdíl.<br  />
</p>
<h3><a class="anchor" id="ClippingTheory"></a>
Teorie</h3>
<p>Ořez (clipping) slouží pro odstranění částí trojúhelníků, které leží mimo pohledový jehlan. Nejdůležitější je však ořez near ořezovou rovinou pohledoveho jehlanu. Pokud by se neprovedl ořez pomocí near roviny, pak by se vrcholy nebo i celé trojúhělníky, které leží za středem projekce promítly při perspektivním dělení na průmětnu. Ořez se provádí v clip-space - po Primitive Assembly jednotce. Pro body, které leží uvnitř pohledového tělesa platí, že jejich souřadnice splňují následující nerovnice: \( -A_w \leq A_i \leq +A_w \), \(i \in \left\{ x,y,z \right\}\). Těchto 6 nerovnic reprezentuje jednotlivé svěny pohledového jehlanu. Nerovnice \( -A_w \leq A_z \) reprezentuje podmínku pro near ořezovou rovinu. <br  />
 Při ořezu trojúhelníku můžou nastat 4 případy, jsou znázorněny na následujícím obrázku:</p>
<div class="image">
<object type="image/svg+xml" data="clip_variants.svg" style="pointer-events: none;"></object>
<div class="caption">
4 varianty ořezu trojúhelníku pomocí near roviny. Počet vrcholů, které leží před ořezovou rovinou určuje typ ořezu. Při ořezu může vzniknout 0 až 2 nové trojúhelníky.</div></div>
<p>Ořez trojúhelníku pomocí near roviny lze zjednodušit na ořez hran trojúhelníku. Bod na hraně (úsečce) trojúhelníku lze vyjádřit jako: \( \overrightarrow{X(t)} = \overrightarrow{A} + t \cdot (\overrightarrow{B}-\overrightarrow{A}) \), \(t \in [0,1] \). \( \overrightarrow{A}, \overrightarrow{B} \) jsou vrcholy trojúhelníka, \( \overrightarrow{X(t)} \) je bod na hraně a parametr \( t \) udává posun na úsečce.</p>
<div class="image">
<object type="image/svg+xml" data="clip.svg" style="pointer-events: none;"></object>
<div class="caption">
Ořez trojúhelníku pomocí ořezu hran. Při ořezu hran vzniknou nové body, ze kterých jsou následně sestaveny nové trojúhelníky.</div></div>
<p>Souřadnice bodu \( \overrightarrow{X(t)} \) lze určit při vypočtení parametru \( t \), při kterém přestane platit nerovnice pro near rovinu \( -X(t)_w \leq X(t)_z \). Takové místo nastává v situaci \( -X(t)_w = X(t)_z \). Po dosazení z rovnice úsečky lze vztah přepsat na: </p><p class="formulaDsp">
\begin{eqnarray*} -X(t)_w &amp;=&amp; X(t)_z \\ 0 &amp;=&amp; X(t)_w + X(t)_z \\ 0 &amp;=&amp; A_w + t \cdot (B_w-A_w) + A_z + t \cdot (B_z - A_z) \\ 0 &amp;=&amp; A_w + A_z + t \cdot (B_w-A_w+B_z-A_z) \\ -A_w-A_z &amp;=&amp; t \cdot (B_w-A_w+B_z-A_z) \\ \frac{-A_w - A_z}{B_w-A_w+B_z-A_z} &amp;=&amp; t\\ \end{eqnarray*}
</p>
<p>Pozice bodu \( \overrightarrow{X(t)} \) a hodnoty dalších vertex atributů lze vypočítat lineární kombinací hodnot z vrcholů úsečky pomocí parametru \( t \) následovně: \( \overrightarrow{X(t)} = \overrightarrow{A} + t \cdot (\overrightarrow{B}-\overrightarrow{A}) \).</p>
<h3><a class="anchor" id="clippingPractice"></a>
Testy 28-31 - ořez</h3>
<p>Testy, které testují ořez jsou 28. - 31. </p><div class="fragment"><div class="line">izgProject -c --test 28</div>
<div class="line">izgProject -c --test 29</div>
<div class="line">izgProject -c --test 30</div>
<div class="line">izgProject -c --test 31</div>
</div><!-- fragment --><p> Pseudokód ořezu může vypadat takto: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> draw(mem,drawCommand){</div>
<div class="line">  <span class="keywordflow">for</span>(every triangle t){</div>
<div class="line">    Primitive primitive;</div>
<div class="line">    runPrimitiveAssembly(primitive,vertexArray,t,vertexShader)</div>
<div class="line"> </div>
<div class="line">    ClippedPrimitive clipped;</div>
<div class="line">    performeClipping(clipped,primitive);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span>(all clipped triangle c in clipped){</div>
<div class="line">      runPerspectiveDivision(c)</div>
<div class="line">      runViewportTransformation(c,width,height)</div>
<div class="line">      rasterizeTriangle(framebuffer,c,fragmentShader);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="gpu_8cpp.html#a534f9ebe20a4f57bd73b4dfb9bb4b29b">izg_enqueue</a>(mem,commandBuffer){</div>
<div class="line">  <span class="keywordflow">for</span>(every command in commandBuffer){</div>
<div class="line">    <span class="keywordflow">if</span>(isDrawCommand )draw (mem,drawCommand)</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
</div><!-- fragment --><p> Pokud budete mít ořez hotový, dokončili jste implementaci grafické karty! Byla to fuška, ale věřte, že skutečné grafické karty jsou alespoň milionkrát složitější. Takto vypadá celý vykreslovací řetězec:</p>
<div class="image">
<object type="image/svg+xml" data="rendering_pipeline.svg" style="pointer-events: none;"></object>
<div class="caption">
Simplified rendering pipeline</div></div>
<p> Měly by vám fungovat příklady, které nevyžadují načítání modelů: </p><div class="image">
<object type="image/svg+xml" data="examples.svg" width="1000" style="pointer-events: none;"></object>
<div class="caption">
příklady</div></div>
<p> Další úkoly jsou zaměřené už na vykreslování modelů s využitím stínů.</p>
<h1><a class="anchor" id="drawModelSec"></a>
Implementace vykreslování modelů se stíny - soubor student/prepareModel.cpp</h1>
<p>Druhá věc, co se asi ptáte je: "K čemu se dá grafická karta využít?" Cílem této části projektu je vykreslit modely se stíny pomocí vámi vytvořené grafické karty. Všechny úkoly této části se týkají souboru <a class="el" href="prepareModel_8cpp.html" title="This file contains functions for model rendering.">student/prepareModel.cpp</a>.</p>
<h2><a class="anchor" id="drawModel_fce"></a>
8. Úkol - Vykreslování modelů - funkce prepareModel</h2>
<p>Tento úkol už se neváže k zobrazovacímu řetězci, ale k jeho využívání. Cílem je naprogramovat zobrazování modelů načtených ze souboru na disku. Načítání modelů už je uděláno a předpřipraveno. Vaším úkolem je jen správně vytvořit command buffer a zapsat správně data do grafické karty. Budete editovat funkci <a class="el" href="prepareModel_8hpp.html#af46f2952d390459f20fc55a1eb8f4f30">prepareModel</a> v souboru <a class="el" href="prepareModel_8cpp.html">student/prepareModel.cpp</a>. Samotné volání kreslení nebudete dělat, připravujete command buffer a paměť, které zpracuje příklad modelMethod.cpp.<br  />
 Struktura modelu je: </p><div class="image">
<object type="image/svg+xml" data="model.svg" style="pointer-events: none;"></object>
<div class="caption">
Model je složen ze 4 polí: pole kořenů, pole meshu, pole bufferů a pole textur. Kořen je uzel, který může mít potomky a může se odkazovat na mesh. Mesh obsahuje nastavení pro DrawCommand a může se odkazovat na texturu a buffery.</div></div>
<p> Vážou s k němu struktury <a class="el" href="structModel.html" title="[Node]">Model</a>, <a class="el" href="structNode.html" title="[Mesh]">Node</a>, <a class="el" href="structMesh.html" title="This struct represents a mesh.">Mesh</a>, <a class="el" href="structBuffer.html" title="[Framebuffer]">Buffer</a>, <a class="el" href="structTexture.html" title="[Image]">Texture</a>. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structModel.html">Model</a>{</div>
<div class="line">  std::vector&lt;Mesh   &gt;<a class="code" href="structModel.html#a6797d253b3c7ca6f90a99d1b7abd0b79">meshes</a>  ;</div>
<div class="line">  std::vector&lt;Node   &gt;<a class="code" href="structModel.html#ac1fcef5b98a4c88e5fec3672180e85f1">roots</a>   ;</div>
<div class="line">  std::vector&lt;Texture&gt;<a class="code" href="structModel.html#ace109d8eec99777f72694b7d49b2224f">textures</a>;</div>
<div class="line">  std::vector&lt;Buffer&gt; <a class="code" href="structModel.html#a39a2739a54833484f1ce7f951cf58e1e">buffers</a> ;</div>
<div class="line">};</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structNode.html">Node</a>{</div>
<div class="line">  glm::mat4        <a class="code" href="structNode.html#a825a38e1f0d49fcc1a0cdbad46473bf2">modelMatrix</a> = glm::mat4(1.f);</div>
<div class="line">  int32_t          <a class="code" href="structNode.html#ad4e3fcf9fdbd325a83e87cfb7ab86554">mesh</a>        = -1;            </div>
<div class="line">  std::vector&lt;Node&gt;<a class="code" href="structNode.html#af7ddc81358470c3bf7a7819c8b77f53d">children</a>;                    </div>
<div class="line">};</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structMesh.html">Mesh</a>{</div>
<div class="line">  int32_t      <a class="code" href="structMesh.html#a6ee7d4182d7a50b63cafca5b0b66c715">indexBufferID</a>  = -1               ;</div>
<div class="line">  <span class="keywordtype">size_t</span>       <a class="code" href="structMesh.html#ae334cf0d47655e3daefe644b574468d5">indexOffset</a>    = 0                ;</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a862161defe984b09e24dfec9e0540a3e">IndexType</a>    <a class="code" href="structMesh.html#a55de606f67f2aa169ef7b51042ade990">indexType</a>      = <a class="code" href="fwd_8hpp.html#a862161defe984b09e24dfec9e0540a3ea17266551181f69a1b4a3ad5c9e270afc">IndexType::UINT32</a>;</div>
<div class="line">  <a class="code" href="structVertexAttrib.html">VertexAttrib</a> <a class="code" href="structMesh.html#a00f5a9d0221fc4e66dc165520a835460">position</a>                          ;</div>
<div class="line">  <a class="code" href="structVertexAttrib.html">VertexAttrib</a> <a class="code" href="structMesh.html#abc59ae5bf8f9b8d5b806e6e91ae5e1f5">normal</a>                            ;</div>
<div class="line">  <a class="code" href="structVertexAttrib.html">VertexAttrib</a> <a class="code" href="structMesh.html#a64c4b4488ba4d235f2b6e7c0e4d47cd7">texCoord</a>                          ;</div>
<div class="line">  uint32_t     <a class="code" href="structMesh.html#ad60502867a78d6e442172d1ea5b679d6">nofIndices</a>     = 0                ;</div>
<div class="line">  glm::vec4    <a class="code" href="structMesh.html#a12235d3eae977558b64d1f5ec3022db7">diffuseColor</a>   = glm::vec4(1.f)   ;</div>
<div class="line">  <span class="keywordtype">int</span>          <a class="code" href="structMesh.html#ad0ab81099a4d195182afafa8c03c8371">diffuseTexture</a> = -1               ;</div>
<div class="line">  <span class="keywordtype">bool</span>         <a class="code" href="structMesh.html#abc3edaf6225dd67400f33e59edc598c4">doubleSided</a>    = false            ;</div>
<div class="line">};</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structBuffer.html">Buffer</a>{</div>
<div class="line">  <span class="keywordtype">void</span> <span class="keyword">const</span>* <a class="code" href="structBuffer.html#a8fbe8b3fba53c8ff7fcd44f9c4f463c7">data</a> = <span class="keyword">nullptr</span>; </div>
<div class="line">  uint64_t    <a class="code" href="structBuffer.html#a3d37b3ab0942c1222347f8de7520f9ef">size</a> = 0      ; </div>
<div class="line">};</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structTexture.html">Texture</a>{</div>
<div class="line">  <a class="code" href="structImage.html">Image</a>    <a class="code" href="structTexture.html#a64d1fdc3117ab704bc4c4c9696d7237e">img</a>       ; </div>
<div class="line">  uint32_t <a class="code" href="structTexture.html#a48c85d8e7c257d854238980f5bcc3b75">width</a>  = 0; </div>
<div class="line">  uint32_t <a class="code" href="structTexture.html#a35691eb813ceb8467b436092b1c9d8ed">height</a> = 0; </div>
<div class="line">};</div>
</div><!-- fragment --><p> Pro správné vytvoření command bufferu je potřeba projít kořeny modelu a vložit všechny uzly, které mají mesh. Procházejte stromy průchodem <a href="https://en.wikipedia.org/wiki/Tree_traversal">pre order</a>. Uzly se mohou odkazovat na mesh nebo nemusí (pokud je mesh=-1).<br  />
 <a class="el" href="structMesh.html" title="This struct represents a mesh.">Mesh</a> se může odkazovat na texturu nebo nemusí (pokud je diffuseTexture=-1).<br  />
 V zásadě jde o to ke každému uzlu, ve kterém je odkaz na mesh, vytvořit <a class="el" href="structDrawCommand.html" title="[ClearCommand]">DrawCommand</a> a vložit jej do <a class="el" href="structCommandBuffer.html" title="[Command]">CommandBuffer</a> a vytvořit <a class="el" href="structVertexArray.html" title="[VertexAttrib]">VertexArray</a> a vložit jej do paměti grafické karty <a class="el" href="structGPUMemory.html" title="[Buffer]">GPUMemory</a>.<br  />
 Je potřeba správně spočítat modelové matice, které se budují postupný pronásobováním z kořenového uzlu.<br  />
 Vytvoření command bufferu lze napsat s výhodou rekurzivně. Pseudokód možné implementace: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> prepareNode(<a class="code" href="structGPUMemory.html">GPUMemory</a>&amp;mem,<a class="code" href="structCommandBuffer.html">CommandBuffer</a>&amp;cb,<a class="code" href="structNode.html">Node</a> <span class="keyword">const</span>&amp;node,<a class="code" href="structModel.html">Model</a> <span class="keyword">const</span>&amp;model,glm::mat4 <span class="keyword">const</span>&amp;prubeznaMatice,...){</div>
<div class="line">  <span class="keywordflow">if</span>(node.<a class="code" href="structNode.html#ad4e3fcf9fdbd325a83e87cfb7ab86554">mesh</a>&gt;=0){</div>
<div class="line">    <a class="code" href="structMesh.html">Mesh</a> mesh = model.<a class="code" href="structModel.html#a6797d253b3c7ca6f90a99d1b7abd0b79">meshes</a>[node.<a class="code" href="structNode.html#ad4e3fcf9fdbd325a83e87cfb7ab86554">mesh</a>];</div>
<div class="line"> </div>
<div class="line">    drawCounter; <span class="comment">// pocitadlo kreslicich prikazu</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// vytvoření vertex array</span></div>
<div class="line">    <a class="code" href="structVertexArray.html">VertexArray</a> vao;</div>
<div class="line">    vao.<a class="code" href="structVertexArray.html#a7648ec169177dbb70b495b51ffcfb606">indexBufferID</a> = mesh.<a class="code" href="structMesh.html#a6ee7d4182d7a50b63cafca5b0b66c715">indexBufferID</a>;</div>
<div class="line">    vao.<a class="code" href="structVertexArray.html#a89b9faa058891874f5bf63064deafe99">indexOffset</a> = ...;</div>
<div class="line">    vao.<a class="code" href="structVertexArray.html#a7822420a93f7334ffdb1a0992de59ae3">indexType</a> = ...;</div>
<div class="line">    vao.<a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[0] = ...; <span class="comment">// pozice</span></div>
<div class="line">    vao.<a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[1] = ...; <span class="comment">// normala</span></div>
<div class="line">    vao.<a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[2] = ...; <span class="comment">// texturovaci souradnice</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// vlozeni vao na spravne misto v pameti (aby jej bylo mozne najit </span></div>
<div class="line">    mem.<a class="code" href="structGPUMemory.html#acab4bb492d24e78131d39ea7997266cb">vertexArrays</a>[drawCounter] = vao;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="structBindVertexArrayCommand.html">BindVertexArrayCommand</a> bindVaoCmd;</div>
<div class="line">    bindVaoCmd.<a class="code" href="structBindVertexArrayCommand.html#a2dedaac94feb65b7c932753adba273e9">id</a> = drawCounter;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="structDrawCommand.html">DrawCommand</a> drawCmd;</div>
<div class="line">    drawCmd.<a class="code" href="structDrawCommand.html#aff1a6f40fd082c3a0065b5fa3998a753">backfaceCulling</a> = ...; <span class="comment">// pokud je double sided tak by se nemelo orezavat</span></div>
<div class="line">    drawCmd.<a class="code" href="structDrawCommand.html#a4a7376486faf9f07fccb7de82d86566b">nofVertices</a> = ...; <span class="comment">// pocet vertexu</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// vlozeni bindVaoCmd a drawCmd do command buffer cb</span></div>
<div class="line">    cb.<a class="code" href="structCommandBuffer.html#addba1f7b3ffb5ad52a484d1b815436df">commands</a>[...    ] = bindVaoCmd;</div>
<div class="line">    cb.<a class="code" href="structCommandBuffer.html#addba1f7b3ffb5ad52a484d1b815436df">commands</a>[... +1 ] = drawCmd   ;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">//zapis uniformnich dat do pameti</span></div>
<div class="line">    ZKOBINUJ(prubeznaMatice,node.<a class="code" href="structNode.html#a825a38e1f0d49fcc1a0cdbad46473bf2">modelMatrix</a>);</div>
<div class="line">    vypocitej inverzni transponovanou matici pro normaly...</div>
<div class="line"> </div>
<div class="line">    mem.<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>[10+drawCounter*5+0].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a> = modelMatrix</div>
<div class="line">    mem.<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>[10+drawCounter*5+1].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a> = inverzniTransponovana Modelova</div>
<div class="line">    mem.<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>[10+drawCounter*5+2].<a class="code" href="unionUniform.html#ad2afb58e290202cd23e444440e1b1f07">v4</a> = difuzni barva</div>
<div class="line">    mem.<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>[10+drawCounter*5+3].<a class="code" href="unionUniform.html#a8449fdf21a57c7e30991794dd81c3b74">i1</a> = <span class="keywordtype">id</span> textury nebo -1 pokud neni</div>
<div class="line">    mem.<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>[10+drawCounter*5+4].<a class="code" href="unionUniform.html#a2714f4ff3e6703bccdac2c92dcad3b25">v1</a> = <span class="keywordtype">double</span> sided</div>
<div class="line">    writeToMemory(mem);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0;i&lt;node.<a class="code" href="structNode.html#af7ddc81358470c3bf7a7819c8b77f53d">children</a>.size();++i)</div>
<div class="line">    prepareNode(mem,node.<a class="code" href="structNode.html#af7ddc81358470c3bf7a7819c8b77f53d">children</a>[i],model,...); rekurze</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="prepareModel_8cpp.html#af46f2952d390459f20fc55a1eb8f4f30">prepareModel</a>(<a class="code" href="structGPUMemory.html">GPUMemory</a>&amp;mem,<a class="code" href="structCommandBuffer.html">CommandBuffer</a>&amp;cb,<a class="code" href="structModel.html">Model</a> <span class="keyword">const</span>&amp;model){</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a4755d327262c8020766718bb31f92d0b">buffers</a>  = ...;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#ac07704dd918f18a48644abdabbdf6f0d">textures</a> = ...;</div>
<div class="line"> </div>
<div class="line">  glm::mat4 jednotkovaMatrice = glm::mat4(1.f);</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0;i&lt;model.<a class="code" href="structModel.html#ac1fcef5b98a4c88e5fec3672180e85f1">roots</a>.size();++i)</div>
<div class="line">    prepareNode(mem,cb,model.<a class="code" href="structModel.html#ac1fcef5b98a4c88e5fec3672180e85f1">roots</a>[i],jednotkovaMatrice,...);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Příklad, jak připravit command buffer, můžete najít v souboru examples/phongMethod.cpp </p><div class="fragment"><div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> vertexShader(<a class="code" href="structOutVertex.html">OutVertex</a>&amp;outVertex,<a class="code" href="structInVertex.html">InVertex</a> <span class="keyword">const</span>&amp;inVertex,<a class="code" href="structShaderInterface.html">ShaderInterface</a> <span class="keyword">const</span>&amp;si){</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> pos = glm::vec4(inVertex.<a class="code" href="structInVertex.html#a4fc269d49110daa41aedf9b8f313f0ca">attributes</a>[0].<a class="code" href="unionAttribute.html#a7e4149eff36adcf056cb7153bfbf4c8c">v3</a>,1.f);</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp;nor = inVertex.<a class="code" href="structInVertex.html#a4fc269d49110daa41aedf9b8f313f0ca">attributes</a>[1].<a class="code" href="unionAttribute.html#a7e4149eff36adcf056cb7153bfbf4c8c">v3</a>;</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp;viewMatrix       = si.<a class="code" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[0].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a>;</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp;projectionMatrix = si.<a class="code" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[1].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> mvp = projectionMatrix*viewMatrix;</div>
<div class="line"> </div>
<div class="line">  outVertex.<a class="code" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a> = mvp * pos;</div>
<div class="line">  outVertex.<a class="code" href="structOutVertex.html#ad1d48203a36e3ee510841f25a5bc068e">attributes</a>[0].<a class="code" href="unionAttribute.html#a7e4149eff36adcf056cb7153bfbf4c8c">v3</a> = pos;</div>
<div class="line">  outVertex.<a class="code" href="structOutVertex.html#ad1d48203a36e3ee510841f25a5bc068e">attributes</a>[1].<a class="code" href="unionAttribute.html#a7e4149eff36adcf056cb7153bfbf4c8c">v3</a> = nor;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> fragmentShader(<a class="code" href="structOutFragment.html">OutFragment</a>&amp;outFragment,<a class="code" href="structInFragment.html">InFragment</a> <span class="keyword">const</span>&amp;inFragment,<a class="code" href="structShaderInterface.html">ShaderInterface</a> <span class="keyword">const</span>&amp;si){</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp; light          = si.<a class="code" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[2].<a class="code" href="unionUniform.html#a70392e438c775c6213e6c2dec76b29c4">v3</a>;</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp; cameraPosition = si.<a class="code" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[3].<a class="code" href="unionUniform.html#a70392e438c775c6213e6c2dec76b29c4">v3</a>;</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp; vpos           = inFragment.<a class="code" href="structInFragment.html#af9cd9e9a684a1c454d52d7e191564be1">attributes</a>[0].<a class="code" href="unionAttribute.html#a7e4149eff36adcf056cb7153bfbf4c8c">v3</a>;</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp; vnor           = inFragment.<a class="code" href="structInFragment.html#af9cd9e9a684a1c454d52d7e191564be1">attributes</a>[1].<a class="code" href="unionAttribute.html#a7e4149eff36adcf056cb7153bfbf4c8c">v3</a>;</div>
<div class="line">  <span class="keyword">auto</span> vvnor = glm::normalize(vnor);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> l = glm::normalize(light-vpos);</div>
<div class="line">  <span class="keywordtype">float</span> diffuseFactor                    = glm::dot(l, vvnor);</div>
<div class="line">  <span class="keywordflow">if</span> (diffuseFactor &lt; 0.f) diffuseFactor = 0.f;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> v = glm::normalize(cameraPosition-vpos);</div>
<div class="line">  <span class="keyword">auto</span> r = -glm::reflect(v,vvnor);</div>
<div class="line">  <span class="keywordtype">float</span> specularFactor                     = glm::dot(r, l);</div>
<div class="line">  <span class="keywordflow">if</span> (specularFactor &lt; 0.f) specularFactor = 0.f;</div>
<div class="line">  <span class="keywordtype">float</span> <span class="keyword">const</span> shininess                    = 40.f;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (diffuseFactor &lt; 0)</div>
<div class="line">    specularFactor = 0;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    specularFactor = powf(specularFactor, shininess);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">float</span> t = vvnor[1];</div>
<div class="line">  <span class="keywordflow">if</span>(t&lt;0.f)t=0.f;</div>
<div class="line">  t*=t;</div>
<div class="line">  <span class="keyword">auto</span> materialDiffuseColor = glm::mix(glm::vec3(0.f,1.f,0.f),glm::vec3(1.f,1.f,1.f),t);</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">float</span> <span class="keyword">const</span> nofStripes = 10;</div>
<div class="line">  <span class="keywordtype">float</span> factor = 1.f / nofStripes * 2.f;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> xs = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(glm::mod(vpos.x+glm::sin(vpos.y*10.f)*.1f,factor)/factor &gt; 0.5);</div>
<div class="line"> </div>
<div class="line">  materialDiffuseColor = glm::mix(glm::mix(glm::vec3(0.f,.5f,0.f),glm::vec3(1.f,1.f,0.f),xs),glm::vec3(1.f),t);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> materialSpecularColor = glm::vec3(1.f);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> diffuseColor  = materialDiffuseColor  * diffuseFactor;</div>
<div class="line">  <span class="keyword">auto</span> specularColor = materialSpecularColor * specularFactor;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> color = glm::min(diffuseColor + specularColor,glm::vec3(1.f));</div>
<div class="line">  outFragment.<a class="code" href="structOutFragment.html#a9670bf5a31a5c23fccdbeaad959cc3cf">gl_FragColor</a> = glm::vec4(color,1.f);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Method::Method(<a class="code" href="structGPUMemory.html">GPUMemory</a>&amp;m,MethodConstructionData <span class="keyword">const</span>*): ::Method(m){</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a4755d327262c8020766718bb31f92d0b">buffers</a>[0].<a class="code" href="structBuffer.html#a8fbe8b3fba53c8ff7fcd44f9c4f463c7">data</a> = (<span class="keywordtype">void</span> <span class="keyword">const</span>*)bunnyVertices;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a4755d327262c8020766718bb31f92d0b">buffers</a>[0].<a class="code" href="structBuffer.html#a3d37b3ab0942c1222347f8de7520f9ef">size</a> = <span class="keyword">sizeof</span>(bunnyVertices);</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a4755d327262c8020766718bb31f92d0b">buffers</a>[1].<a class="code" href="structBuffer.html#a8fbe8b3fba53c8ff7fcd44f9c4f463c7">data</a> = (<span class="keywordtype">void</span> <span class="keyword">const</span>*)bunnyIndices;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a4755d327262c8020766718bb31f92d0b">buffers</a>[1].<a class="code" href="structBuffer.html#a3d37b3ab0942c1222347f8de7520f9ef">size</a> = <span class="keyword">sizeof</span>(bunnyIndices);</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a50091de928f20fa9d84c6bd137dab3a6">programs</a>[0].<a class="code" href="structProgram.html#a2bcea678985527f04a87be358ff1f78b">vertexShader</a>   = vertexShader;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a50091de928f20fa9d84c6bd137dab3a6">programs</a>[0].<a class="code" href="structProgram.html#a5faf623d0af27d6000ebcacafecf2eb5">fragmentShader</a> = fragmentShader;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a50091de928f20fa9d84c6bd137dab3a6">programs</a>[0].<a class="code" href="structProgram.html#a5b48bbf6bc459552b066757369a0f86d">vs2fs</a>[0]       = <a class="code" href="fwd_8hpp.html#addfd10ead04eeadec78064481a4a3f4daa7c116def9f212182aa52ab1e936d77d">AttributeType::VEC3</a>;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a50091de928f20fa9d84c6bd137dab3a6">programs</a>[0].<a class="code" href="structProgram.html#a5b48bbf6bc459552b066757369a0f86d">vs2fs</a>[1]       = <a class="code" href="fwd_8hpp.html#addfd10ead04eeadec78064481a4a3f4daa7c116def9f212182aa52ab1e936d77d">AttributeType::VEC3</a>;</div>
<div class="line"> </div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#acab4bb492d24e78131d39ea7997266cb">vertexArrays</a>[0].<a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[0].<a class="code" href="structVertexAttrib.html#a4578d3605e0f61b7bfd1f5e24df7c9bf">bufferID</a>   = 0                  ;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#acab4bb492d24e78131d39ea7997266cb">vertexArrays</a>[0].<a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[0].<a class="code" href="structVertexAttrib.html#a0b722b51b4528b50603e99722329d41a">type</a>       = <a class="code" href="fwd_8hpp.html#addfd10ead04eeadec78064481a4a3f4daa7c116def9f212182aa52ab1e936d77d">AttributeType::VEC3</a>;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#acab4bb492d24e78131d39ea7997266cb">vertexArrays</a>[0].<a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[0].<a class="code" href="structVertexAttrib.html#aef250d71bce43e96a6efb9180f24d079">stride</a>     = <span class="keyword">sizeof</span>(BunnyVertex);</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#acab4bb492d24e78131d39ea7997266cb">vertexArrays</a>[0].<a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[0].<a class="code" href="structVertexAttrib.html#a58f3129f893d0ce72ec7d364fef21840">offset</a>     = 0                  ;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#acab4bb492d24e78131d39ea7997266cb">vertexArrays</a>[0].<a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[1].<a class="code" href="structVertexAttrib.html#a4578d3605e0f61b7bfd1f5e24df7c9bf">bufferID</a>   = 0                  ;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#acab4bb492d24e78131d39ea7997266cb">vertexArrays</a>[0].<a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[1].<a class="code" href="structVertexAttrib.html#a0b722b51b4528b50603e99722329d41a">type</a>       = <a class="code" href="fwd_8hpp.html#addfd10ead04eeadec78064481a4a3f4daa7c116def9f212182aa52ab1e936d77d">AttributeType::VEC3</a>;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#acab4bb492d24e78131d39ea7997266cb">vertexArrays</a>[0].<a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[1].<a class="code" href="structVertexAttrib.html#aef250d71bce43e96a6efb9180f24d079">stride</a>     = <span class="keyword">sizeof</span>(BunnyVertex);</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#acab4bb492d24e78131d39ea7997266cb">vertexArrays</a>[0].<a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[1].<a class="code" href="structVertexAttrib.html#a58f3129f893d0ce72ec7d364fef21840">offset</a>     = <span class="keyword">sizeof</span>(glm::vec3)  ;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#acab4bb492d24e78131d39ea7997266cb">vertexArrays</a>[0].<a class="code" href="structVertexArray.html#a7648ec169177dbb70b495b51ffcfb606">indexBufferID</a> = 1                ;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#acab4bb492d24e78131d39ea7997266cb">vertexArrays</a>[0].<a class="code" href="structVertexArray.html#a89b9faa058891874f5bf63064deafe99">indexOffset</a>   = 0                ;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#acab4bb492d24e78131d39ea7997266cb">vertexArrays</a>[0].<a class="code" href="structVertexArray.html#a7822420a93f7334ffdb1a0992de59ae3">indexType</a>     = <a class="code" href="fwd_8hpp.html#a862161defe984b09e24dfec9e0540a3ea17266551181f69a1b4a3ad5c9e270afc">IndexType::UINT32</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a8f837089b3ff5f5c2ebc125f4000fdd4">pushClearCommand</a>(commandBuffer,glm::vec4(.5,.5,.5,1));</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#ad35fa691c90051fd7b24f95fb6c4b55d">pushBindProgramCommand</a>(commandBuffer,0);</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a6a83b6ff420e4e17a9aef5a4a11a2499">pushBindVertexArrayCommand</a>(commandBuffer,0);</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#ad5d24f6d5d3b90ad155197ce8edf694c">pushDrawCommand</a> (commandBuffer,<span class="keyword">sizeof</span>(bunnyIndices)/<span class="keyword">sizeof</span>(VertexIndex));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Method::onDraw(SceneParam <span class="keyword">const</span>&amp;sceneParam){</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>[0].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a> = sceneParam.view  ;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>[1].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a> = sceneParam.proj  ;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>[2].<a class="code" href="unionUniform.html#a70392e438c775c6213e6c2dec76b29c4">v3</a> = sceneParam.light ;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>[3].<a class="code" href="unionUniform.html#a70392e438c775c6213e6c2dec76b29c4">v3</a> = sceneParam.camera;</div>
<div class="line">  </div>
<div class="line">  <a class="code" href="gpu_8cpp.html#a534f9ebe20a4f57bd73b4dfb9bb4b29b">izg_enqueue</a>(mem,commandBuffer);</div>
<div class="line">}</div>
<div class="line"> </div>
</div><!-- fragment --><p> K tomuto úkolu se vážou testy 32. až 45 </p><div class="fragment"><div class="line">./izgProject -c --test 32</div>
<div class="line">./izgProject -c --test 33</div>
<div class="line">...</div>
<div class="line">./izgProject -c --test 45</div>
</div><!-- fragment --><h3><a class="anchor" id="modelTraverse"></a>
Testy 32-37 - Průchod modelem</h3>
<p>Testy 32. - 37. kontrolují, jestli správně vytváříte command buffer.</p>
<h3><a class="anchor" id="modelMemory"></a>
Testy 38-35 - paměť</h3>
<p>Testy 38. - 35. kontrolují, jestli správně plníte paměť grafické karty.</p>
<h2><a class="anchor" id="drawModel_vs"></a>
9. Úkol - Vykreslování modelů - vertex shader drawModel_vertexShader</h2>
<p>Funkce <a class="el" href="prepareModel_8hpp.html#a0224939bb488063ed7ba3a75659e4616">drawModel_vertexShader</a> reprezentuje vertex shader pro zobrazení modelů.<br  />
 Jeho funkcionalita spočívá v transformování vrcholů pomocí matic.<br  />
 Vstupem jsou vrcholy, které mají pozici (3f), normálu (3f) a texturovací souřadnice (2f) (atributy 0, 1 a 2).<br  />
 Vertex Attributy <a class="el" href="structInVertex.html" title="[Attribute]">InVertex</a>: </p><ul>
<li>
inVertex.attributes[0].v3 - pozice vertexu v model-space </li>
<li>
inVertex.attributes[1].v3 - normála vertexu v model-space </li>
<li>
inVertex.attributes[2].v2 - tex. koordináty </li>
</ul>
<p>Výstupem jsou vrcholy, které mají pozici (3f) a normálu (3f) ve world space, texturovací souřadnice (2f) a pozici vrcholu v clip-space světla (4f) (atributy 0, 1, 2, 3).<br  />
 Vertex Attributy <a class="el" href="structOutVertex.html" title="[InVertex]">OutVertex</a>: </p><ul>
<li>
outVertex.attributes[0].v3 - pozice vertexu ve world-space </li>
<li>
outVertex.attributes[1].v3 - normála vertexu ve world-space </li>
<li>
outVertex.attributes[2].v2 - tex. koordináty </li>
<li>
outVertex.attributes[3].v4 - pozice vertexu v clip-space světla. </li>
</ul>
<p>Uniformní proměnné obsahují projectionView matici, modelovou matici, a inverzní transponovanou matici.<br  />
 Uniformní proměnné Uniforms: </p><ul>
<li>
si.uniforms[0].m4 - cameraProjectionView projekční a view matice kamery </li>
<li>
si.uniforms[3].m4 - lightProjectionView projekční a view matice světla - pro stíny </li>
<li>
si.uniforms[10+gl_DrawID*5+0].m4 - modelová matice </li>
<li>
si.uniforms[10+gl_DrawID*5+1].m4 - inverzní transponovaná matice </li>
<li>
s.gl_DrawID - číslo vykreslovacího příkazu </li>
</ul>
<p>Pozice by se měla pronásobit modelovou maticí "m*glm::vec4(pos,1.f)", aby se ztransformovala do world-space.<br  />
 Normála by se měla pronásobit inverzní transponovanou modelovou maticí "itm*glm::vec4(nor,0.f)" aby se dostala do world-space.<br  />
 Texturovací souřadnice se pouze přepošlou.<br  />
 Pozice vrcholu gl_Position by měla být vypočtena pronásobením cameraProjectionView*model*pos.<br  />
 Pozice vrcholu v prostoru clip-space prostoru světla pro stíny by se měla vypočítat lightProjectionView*model*pos.<br  />
 K tomuto úkolu se váže tests 46. </p><div class="fragment"><div class="line">izgProject -c --test 46</div>
</div><!-- fragment --><h2><a class="anchor" id="drawModel_fs"></a>
10. Úkol - Vykreslování modelů - fragment shader drawMode_fragmentShader</h2>
<p>Funkce <a class="el" href="prepareModel_8hpp.html#a4fb632ea1b28681c59ef705725611573">drawModel_fragmentShader</a> reprezentuje fragment shader pro zobrazení modelů.<br  />
 Jeho funkcionalita spočívá v obarvování fragmentů, počítání lambertova osvětlovacího modelu a výpočtu stínu.<br  />
 Vstupem jsou fragmenty, které mají: pozici (3f), normálu (3f), texturovací souřadnice (2f) a pozici v clip-space prostoru světla pro čtení ze stínové mapy. (atributy 0,1,2,3).<br  />
 Fragment Attributy <a class="el" href="structInFragment.html" title="[OutVertex]">InFragment</a>: </p><ul>
<li>
inFragment.attributes[0].v3 - pozice fragmentu ve world-space </li>
<li>
inFragment.attributes[1].v3 - normála fragmentu ve world-space </li>
<li>
inFragment.attributes[2].v2 - tex. koordináty </li>
<li>
inFragment.attributes[3].v4 - pozice fragmentu v clip-space světla pro adresaci stínové mapy a výpočet stínu </li>
</ul>
<p>Výstupem je fragment s barvou a správnou průhledností \(\alpha\).</p>
<p>Uniformní proměnné obsahují pozici světla (3f), pozici kamery (3f), difuzní barvu (4f), číslo textury (1i) a příznak doubleSided (1f).<br  />
 Vzhledem k tomu, že má každý mesh jinou texturu a jiné nastavení, je nutné najít správné textury podle gl_DrawID.<br  />
 Uniformní proměnné Uniforms: </p><ul>
<li>
si.uniforms[1].v3 - pozice světla ve world-space </li>
<li>
si.uniforms[2].v3 - pozice kamery ve world-space </li>
<li>
si.uniforms[6].i1 - číslo textury, která obsahuje stínovou mapu, nebo -1 pokud stíny nejsou </li>
<li>
si.uniforms[7].v3 - barva ambientního světla </li>
<li>
si.uniforms[8].v3 - barva světla </li>
<li>
si.uniforms[10+gl_DrawID*5+2].v4 - difuzní barva </li>
<li>
si.uniforms[10+gl_DrawID*5+3].i1 - číslo textury nebo -1 pokud textura není </li>
<li>
si.uniforms[10+gl_DrawID*5+4].v1 - příznak doubleSided (1.f pokud je, 0.f pokud není) </li>
</ul>
<p>Vstupní normálu byste měli znormalizovat N=glm::normalize(nor).<br  />
 Difuzní barva materiálu je buď uložena v uniformní proměnné nebo v textuře.<br  />
 Rozhoduje se podle toho, jestli je čístlo textury záporné nebo ne.<br  />
 Pokud je nastaven příznak doubleSided (je &gt; 0), jedná se o doustraný povrch. <br  />
 V takovém případě je nutné otočit normálu, pokud je otočená od kamery (využijte pozici kamery v uniformní proměnné). <br  />
 Spočítejte lambertův osvětlovací model se stíny pomocí shadow mappingu. <br  />
 Spočítejte, zda je fragment ve stínu. <br  />
 K tomu je potřeba vyčíst hloubku ze stínové mapy a porovnat ji se vzdáleností ke světlu.<br  />
 Testy vás povedou.<br  />
 K tomuto úkolu se váže testy 47-51. </p><div class="fragment"><div class="line">izgProject -c --test 47</div>
<div class="line">izgProject -c --test 48</div>
<div class="line">izgProject -c --test 49</div>
<div class="line">izgProject -c --test 50</div>
<div class="line">izgProject -c --test 51</div>
</div><!-- fragment --><p>Ukázka, jak se počítá celý shadow mapping je v souboru: </p><div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">class </span>Method: <span class="keyword">public</span> ::Method{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    Method(<a class="code" href="structGPUMemory.html">GPUMemory</a>&amp;m,MethodConstructionData <span class="keyword">const</span>*);</div>
<div class="line">    <span class="keyword">virtual</span> ~Method(){}</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onDraw(SceneParam <span class="keyword">const</span>&amp;sceneParam) <span class="keyword">override</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onUpdate(<span class="keywordtype">float</span> dt) <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">float</span> time = 0;</div>
<div class="line">    <a class="code" href="structCommandBuffer.html">CommandBuffer</a> commandBuffer;</div>
<div class="line">    TextureData shadowMap;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// struktura reprezentujici vertex</span></div>
<div class="line"><span class="keyword">struct </span>Vertex{</div>
<div class="line">  vec3 pos; <span class="comment">// pozice</span></div>
<div class="line">  vec3 col; <span class="comment">// barva</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// vertex sceny - dva čtverce, jeden zeleny a druhy červený</span></div>
<div class="line">Vertex <span class="keyword">const</span> vertices[] = {</div>
<div class="line">  {vec3(-8,8,-8),vec3(1,0,0)},</div>
<div class="line">  {vec3(+8,8,-8),vec3(1,0,0)},</div>
<div class="line">  {vec3(-8,8,+8),vec3(1,0,0)},</div>
<div class="line">  {vec3(-8,8,+8),vec3(1,0,0)},</div>
<div class="line">  {vec3(+8,8,-8),vec3(1,0,0)},</div>
<div class="line">  {vec3(+8,8,+8),vec3(1,0,0)},</div>
<div class="line"> </div>
<div class="line">  {vec3(-100,0,-100),vec3(0,1,0)},</div>
<div class="line">  {vec3(+100,0,-100),vec3(0,1,0)},</div>
<div class="line">  {vec3(-100,0,+100),vec3(0,1,0)},</div>
<div class="line">  {vec3(-100,0,+100),vec3(0,1,0)},</div>
<div class="line">  {vec3(+100,0,-100),vec3(0,1,0)},</div>
<div class="line">  {vec3(+100,0,+100),vec3(0,1,0)},</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// vertex shader pro vytvoření shadow mapy</span></div>
<div class="line"><span class="keywordtype">void</span> createShadowMap_vs(<a class="code" href="structOutVertex.html">OutVertex</a>&amp;outVertex,<a class="code" href="structInVertex.html">InVertex</a> <span class="keyword">const</span>&amp;inVertex,<a class="code" href="structShaderInterface.html">ShaderInterface</a> <span class="keyword">const</span>&amp;si){</div>
<div class="line">  <span class="keyword">auto</span> gl_VertexID = inVertex.<a class="code" href="structInVertex.html#aa4d31911053492bffe4b41dae12ee000">gl_VertexID</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// light view matice</span></div>
<div class="line">  <span class="keyword">auto</span> view = si.<a class="code" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[2].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a>;</div>
<div class="line">  <span class="comment">// light projekční matice </span></div>
<div class="line">  <span class="keyword">auto</span> proj = si.<a class="code" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[3].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// vypočet pozice vrcholu v clip-space</span></div>
<div class="line">  outVertex.<a class="code" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a> = view*vec4(vertices[gl_VertexID].pos,1.f);</div>
<div class="line">  outVertex.<a class="code" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a>.z -= .5f; <span class="comment">// bias (proti self shadowingu)</span></div>
<div class="line">  outVertex.<a class="code" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a> = proj * outVertex.<a class="code" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nepotřebujeme fragment shader, stačí nám hloubka</span></div>
<div class="line"><span class="keywordtype">void</span> createShadowMap_fs(<a class="code" href="structOutFragment.html">OutFragment</a>&amp;,<a class="code" href="structInFragment.html">InFragment</a> <span class="keyword">const</span>&amp;,<a class="code" href="structShaderInterface.html">ShaderInterface</a> <span class="keyword">const</span>&amp;){</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// vertex shader pro výpočet stínu</span></div>
<div class="line"><span class="keywordtype">void</span> scene_vs(<a class="code" href="structOutVertex.html">OutVertex</a>&amp;outVertex,<a class="code" href="structInVertex.html">InVertex</a> <span class="keyword">const</span>&amp;inVertex,<a class="code" href="structShaderInterface.html">ShaderInterface</a> <span class="keyword">const</span>&amp;si){</div>
<div class="line">  <span class="comment">// číslo vrcholu</span></div>
<div class="line">  <span class="keyword">auto</span> gl_VertexID = inVertex.<a class="code" href="structInVertex.html#aa4d31911053492bffe4b41dae12ee000">gl_VertexID</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// view matice kamery</span></div>
<div class="line">  <span class="keyword">auto</span> view = si.<a class="code" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[0].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a>;</div>
<div class="line">  <span class="comment">// projekční matice kamery</span></div>
<div class="line">  <span class="keyword">auto</span> proj = si.<a class="code" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[1].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a>;</div>
<div class="line">  <span class="comment">// view matice světla</span></div>
<div class="line">  <span class="keyword">auto</span> lightView = si.<a class="code" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[2].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a>;</div>
<div class="line">  <span class="comment">// projekční matice světla</span></div>
<div class="line">  <span class="keyword">auto</span> lightProj = si.<a class="code" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[3].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a>;</div>
<div class="line">  <span class="comment">// bias matice světla</span></div>
<div class="line">  <span class="keyword">auto</span> lightBias = si.<a class="code" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[4].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// pozice vertexu ve world-space</span></div>
<div class="line">  <span class="keyword">auto</span> vertex = vec4(vertices[gl_VertexID].pos,1.f);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// zápis barvy</span></div>
<div class="line">  outVertex.<a class="code" href="structOutVertex.html#ad1d48203a36e3ee510841f25a5bc068e">attributes</a>[0].<a class="code" href="unionAttribute.html#a7e4149eff36adcf056cb7153bfbf4c8c">v3</a> = vertices[gl_VertexID].col;</div>
<div class="line">  <span class="comment">// zápis pozice vertexu v clip-space světla, tady jsou uvedeny všechny matice explicitně</span></div>
<div class="line">  outVertex.<a class="code" href="structOutVertex.html#ad1d48203a36e3ee510841f25a5bc068e">attributes</a>[1].<a class="code" href="unionAttribute.html#ac47131c7c30814e28f0c4662a4ed2737">v4</a> = lightBias*lightProj*lightView*vertex;</div>
<div class="line">  <span class="comment">// zápis pozice vertexu v clip-space kamery</span></div>
<div class="line">  outVertex.<a class="code" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a> = proj*view*vertex;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// fragment shader pro výpočet stínu</span></div>
<div class="line"><span class="keywordtype">void</span> scene_fs(<a class="code" href="structOutFragment.html">OutFragment</a>&amp;outFragment,<a class="code" href="structInFragment.html">InFragment</a> <span class="keyword">const</span>&amp;inFragment,<a class="code" href="structShaderInterface.html">ShaderInterface</a> <span class="keyword">const</span>&amp;si){</div>
<div class="line">  <span class="comment">// barva</span></div>
<div class="line">  <span class="keyword">auto</span> color     = inFragment.<a class="code" href="structInFragment.html#af9cd9e9a684a1c454d52d7e191564be1">attributes</a>[0].<a class="code" href="unionAttribute.html#a7e4149eff36adcf056cb7153bfbf4c8c">v3</a>;</div>
<div class="line">  <span class="comment">// pozice fragmentu v clip-space světla</span></div>
<div class="line">  <span class="keyword">auto</span> shadowPos = inFragment.<a class="code" href="structInFragment.html#af9cd9e9a684a1c454d52d7e191564be1">attributes</a>[1].<a class="code" href="unionAttribute.html#ac47131c7c30814e28f0c4662a4ed2737">v4</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// perspektivní dělení</span></div>
<div class="line">  shadowPos/=shadowPos.w;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// vyčtení hloubky ze stínové mapy</span></div>
<div class="line">  <span class="keyword">auto</span> sm = <a class="code" href="gpu_8cpp.html#a688e2ccf23ad94434083e6ecb5709a16">read_textureClamp</a>(si.<a class="code" href="structShaderInterface.html#ad33e6e9e4ff2fbf3853b4430f05188cb">textures</a>[1],glm::vec2(shadowPos)).r;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// je hloubka fragmentu větší než to, co je ve stínové mapě?</span></div>
<div class="line">  <span class="keyword">auto</span> isShadow = (float)(shadowPos.z &gt; sm);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// útlum barvy stínem</span></div>
<div class="line">  color *= (1.f - .5f*isShadow);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// zápis barvy</span></div>
<div class="line">  outFragment.<a class="code" href="structOutFragment.html#a9670bf5a31a5c23fccdbeaad959cc3cf">gl_FragColor</a> = vec4(color,1.f);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">Method::Method(<a class="code" href="structGPUMemory.html">GPUMemory</a>&amp;m,MethodConstructionData <span class="keyword">const</span>*): ::Method(m){</div>
<div class="line">  <span class="comment">// vytvoření stínové mapy (data)</span></div>
<div class="line">  shadowMap = TextureData(m.<a class="code" href="structGPUMemory.html#abd0d80589104a936db46ae766bc7975e">framebuffers</a>[0].<a class="code" href="structFramebuffer.html#ad2efd3ac1249da4ce70d478cd48d0e22">width</a>,m.<a class="code" href="structGPUMemory.html#abd0d80589104a936db46ae766bc7975e">framebuffers</a>[0].<a class="code" href="structFramebuffer.html#a614fd13812430c2ffb379b3b050780c4">height</a>,1,Image::FLOAT32);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// program pro vytvoření stínové mapy</span></div>
<div class="line">  <span class="keyword">auto</span>&amp;prg0 = m.<a class="code" href="structGPUMemory.html#a50091de928f20fa9d84c6bd137dab3a6">programs</a>[0];</div>
<div class="line">  prg0.<a class="code" href="structProgram.html#a2bcea678985527f04a87be358ff1f78b">vertexShader</a>   = createShadowMap_vs;</div>
<div class="line">  prg0.fragmentShader = createShadowMap_fs;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// program pro vykreslení scény se stíny</span></div>
<div class="line">  <span class="keyword">auto</span>&amp;prg1 = m.<a class="code" href="structGPUMemory.html#a50091de928f20fa9d84c6bd137dab3a6">programs</a>[1];</div>
<div class="line">  prg1.<a class="code" href="structProgram.html#a2bcea678985527f04a87be358ff1f78b">vertexShader</a>   = scene_vs;</div>
<div class="line">  prg1.fragmentShader = scene_fs;</div>
<div class="line">  prg1.vs2fs[0] = <a class="code" href="fwd_8hpp.html#addfd10ead04eeadec78064481a4a3f4daa7c116def9f212182aa52ab1e936d77d">AttributeType::VEC3</a>;</div>
<div class="line">  prg1.vs2fs[1] = <a class="code" href="fwd_8hpp.html#addfd10ead04eeadec78064481a4a3f4daee190f7a0572504036effa0134dc5d88">AttributeType::VEC4</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// framebuffer pro vykreslování stínové mapy</span></div>
<div class="line">  m.<a class="code" href="structGPUMemory.html#ac07704dd918f18a48644abdabbdf6f0d">textures</a>[1] = shadowMap.getTexture();</div>
<div class="line">  m.<a class="code" href="structGPUMemory.html#abd0d80589104a936db46ae766bc7975e">framebuffers</a>[1].<a class="code" href="structFramebuffer.html#ad56ef80596abe229e99657865ae8a79b">depth</a>  = m.<a class="code" href="structGPUMemory.html#ac07704dd918f18a48644abdabbdf6f0d">textures</a>[1].<a class="code" href="structTexture.html#a64d1fdc3117ab704bc4c4c9696d7237e">img</a>;</div>
<div class="line">  m.<a class="code" href="structGPUMemory.html#abd0d80589104a936db46ae766bc7975e">framebuffers</a>[1].<a class="code" href="structFramebuffer.html#ad2efd3ac1249da4ce70d478cd48d0e22">width</a>  = m.<a class="code" href="structGPUMemory.html#ac07704dd918f18a48644abdabbdf6f0d">textures</a>[1].<a class="code" href="structTexture.html#a48c85d8e7c257d854238980f5bcc3b75">width</a>;</div>
<div class="line">  m.<a class="code" href="structGPUMemory.html#abd0d80589104a936db46ae766bc7975e">framebuffers</a>[1].<a class="code" href="structFramebuffer.html#a614fd13812430c2ffb379b3b050780c4">height</a> = m.<a class="code" href="structGPUMemory.html#ac07704dd918f18a48644abdabbdf6f0d">textures</a>[1].<a class="code" href="structTexture.html#a35691eb813ceb8467b436092b1c9d8ed">height</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// vykreslení stínové mapy</span></div>
<div class="line">  <a class="code" href="fwd_8hpp.html#aaf908caefd690c7d905eb3baa9e1a569">pushBindFramebufferCommand</a>(commandBuffer,1);</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#ad35fa691c90051fd7b24f95fb6c4b55d">pushBindProgramCommand</a>(commandBuffer,0);</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a8f837089b3ff5f5c2ebc125f4000fdd4">pushClearCommand</a>(commandBuffer,glm::vec4(0,0,0,1));</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#ad5d24f6d5d3b90ad155197ce8edf694c">pushDrawCommand</a>(commandBuffer,12);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// vykreslení scény</span></div>
<div class="line">  <a class="code" href="fwd_8hpp.html#aaf908caefd690c7d905eb3baa9e1a569">pushBindFramebufferCommand</a>(commandBuffer,0);</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#ad35fa691c90051fd7b24f95fb6c4b55d">pushBindProgramCommand</a>(commandBuffer,1);</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a8f837089b3ff5f5c2ebc125f4000fdd4">pushClearCommand</a>(commandBuffer,glm::vec4(0,0,0,1));</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#ad5d24f6d5d3b90ad155197ce8edf694c">pushDrawCommand</a>(commandBuffer,12);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// časovač</span></div>
<div class="line"><span class="keywordtype">void</span> Method::onUpdate(<span class="keywordtype">float</span> dt){</div>
<div class="line">  time += dt;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Method::onDraw(SceneParam <span class="keyword">const</span>&amp;sceneParam){</div>
<div class="line">  <span class="comment">// výpočet matic</span></div>
<div class="line">  <span class="keyword">auto</span> lightView = glm::lookAt(glm::vec3(100*glm::cos(time),100,100*glm::sin(time)),glm::vec3(0,0,0),glm::vec3(0,1,0));</div>
<div class="line">  <span class="keyword">auto</span> lightProj = glm::ortho(-100.f,+100.f,-100.f,+100.f,0.f,1000.f);</div>
<div class="line">  <span class="keyword">auto</span> lightBias = glm::scale(glm::mat4(1.f),glm::vec3(.5f,.5f,1.f))*glm::translate(glm::mat4(1.f),glm::vec3(1,1,0));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// nastavení uniformních proměnných</span></div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>[0].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a> = sceneParam.view;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>[1].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a> = sceneParam.proj;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>[2].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a> = lightView;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>[3].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a> = lightProj;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>[4].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a> = lightBias;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>[5].<a class="code" href="unionUniform.html#a8449fdf21a57c7e30991794dd81c3b74">i1</a> = -1;</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>[7].<a class="code" href="unionUniform.html#a70392e438c775c6213e6c2dec76b29c4">v3</a> = glm::vec3(0.2f);</div>
<div class="line">  mem.<a class="code" href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">uniforms</a>[8].<a class="code" href="unionUniform.html#a70392e438c775c6213e6c2dec76b29c4">v3</a> = glm::vec3(1.f);</div>
<div class="line">  <a class="code" href="gpu_8cpp.html#a534f9ebe20a4f57bd73b4dfb9bb4b29b">izg_enqueue</a>(mem,commandBuffer);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Není třeba jej opisovat, vše je v podstatě uděláno, jen shadery můžete použít jako inspiraci.</p>
<h2><a class="anchor" id="finalCountDown"></a>
11. Úkol - finální render</h2>
<div class="fragment"><div class="line">izgProject -c --test 52</div>
</div><!-- fragment --><p>A je to! Gratuluji k vypracování celého projektu. Děkuji, že jste jej vypracovali celý. Teď by vám mělo fungovat vše. </p><div class="image">
<img src="vystup.png" alt=""/>
</div>
 <div class="image">
<img src="anim.png" alt=""/>
</div>
 <div class="image">
<img src="korea.png" alt=""/>
</div>
<h1><a class="anchor" id="rozdeleni"></a>
Rozdělení souborů a složek</h1>
<p>Projekt je rozdělen do několika podsložek:</p>
<p><b>student/</b> Tato složka obsahuje soubory, které využijete při implementaci projektu. Složka obsahuje soubory, které budete odevzávat a podpůrné hlavičkové soubory.</p>
<p><b>examples/</b> Tato složka obsahuje přiložené příklady, které využívají vámi vytvořené zobrazovadlo.</p>
<p><b>tests/</b> Tato složka obsahuje akceptační a performanční testy projektu. Akceptační testy jsou napsány s využitím knihovny catch. Testy jsou rozděleny do testovacích případů (TEST_CASE). Daný TEST_CASE testuje jednu podčást projektu.</p>
<p><b>libs/</b> Tato složka obsahuje pomocné knihovny <b>framework/</b> Tato složka obsahuje interní záležitosti projektu. Všechny soubory jsou napsány v C++, abyste se mohli podívat, jak to funguje.</p>
<p><b>doc/</b> Tato složka obsahuje doxygen dokumentaci projektu. Můžete ji přegenerovat pomocí příkazu doxygen spuštěného v root adresáři projektu.</p>
<p><b>resources/</b> Tato složka obsahuje modely a obrázky.</p>
<p><b>build/</b> Tady se čeká, že si budete sestavovat projekt, ale není to nutné, pokud víte, co děláte...</p>
<p>Složka student/ obsahuje soubory, které se vás přímo týkají:</p>
<p><a class="el" href="gpu_8cpp.html">gpu.cpp</a> obsahuje definici funkce představující funkcionalitu grafické karty <a class="el" href="gpu_8hpp.html#a534f9ebe20a4f57bd73b4dfb9bb4b29b">izg_enqueue</a> - tady odvedete nejvíce práce.</p>
<p><a class="el" href="prepareModel_8cpp.html">prepareModel.cpp</a> obsahuje definici funkce pro zpracování modelu <a class="el" href="prepareModel_8hpp.html#af46f2952d390459f20fc55a1eb8f4f30">prepareModel</a> a vertex a fragment shaderu <a class="el" href="prepareModel_8hpp.html#a0224939bb488063ed7ba3a75659e4616">drawModel_vertexShader</a> <a class="el" href="prepareModel_8hpp.html#a4fb632ea1b28681c59ef705725611573">drawModel_fragmentShader</a> - toto máte taky naprogramovat.</p>
<p><a class="el" href="fwd_8hpp.html">fwd.hpp</a> obsahuje definice typů a konstanty - projděte si.</p>
<p>Projekt je postaven nad filozofií OpenGL/Vulkan.</p>
<h1><a class="anchor" id="sestaveni"></a>
Sestavení</h1>
<p>Projekt byl testován na Ubuntu 20.04, Visual Studio 2017, 2019. Projekt vyžaduje 64 bitové sestavení. Projekt využívá build systém <a href="https://cmake.org/">CMAKE</a>. CMake je program, který na základně konfiguračních souborů "CMakeLists.txt" vytvoří "makefile" v daném vývojovém prostředí. Dokáže generovat makefile pro Linux, mingw, solution file pro Microsoft Visual Studio, a další.<br  />
 Postup Linux: </p><div class="fragment"><div class="line"># stáhnout projekt</div>
<div class="line">unzip izgProject.zip -d izgProject</div>
<div class="line">cd izgProject/build</div>
<div class="line">cmake ..</div>
<div class="line">make -j8</div>
<div class="line">./izgProject</div>
<div class="line">./izgProject -h</div>
</div><!-- fragment --><p> Posup na Windows:</p><ol type="1">
<li>stáhnout projekt</li>
<li>rozbalit projekt</li>
<li>jděte do složky build/</li>
<li>ve složce build pusťte cmake-gui ..</li>
<li>pokud nevíte jak, tak pusťte cmake-gui a nastavte "Where is the source code:" na složku s projektem (obsahuje CMakeLists.txt)</li>
<li>a "Where to build the binaries: " na složku build</li>
<li>configure</li>
<li>generate</li>
<li>Otevřete vygenerovnou Microsoft Visual Studio Solution soubor.</li>
</ol>
<h1><a class="anchor" id="spousteni"></a>
Spouštění</h1>
<p>Projekt je možné po úspěšném přeložení pustit přes aplikaci <b>izgProject</b>. Projekt akceptuje několik argumentů příkazové řádky, pro jejich výpis použijte parametr <b> -h </b></p><ul>
<li><b>-c</b> spustí akceptační testy.</li>
<li><b>-c -g CESTA_NEKAM/izgProject/resources/images/output.png</b> spustí akceptační cesty (pouze pokud jste si někam nešikovně přesunuli soubory...)</li>
<li><b>-p</b> spustí performanční test. (vhodné až pokud aplikaci zkompilujete v RELEASE) Vyzkoušejte si <div class="fragment"><div class="line">./izgProject -p</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="ovladani"></a>
Ovládání</h1>
<p>Aplikace se ovládá pomocí myši a klávesnice:</p><ul>
<li>stisknuté levé tlačítko myši + pohyb myší - rotace kamery</li>
<li>stisknuté pravé tlačítko myši + pohyb myší - přiblížení kamery</li>
<li>stiknuté prostření tlačítko myši + pohyb myší - posun kamery do boků</li>
<li>"n" - přepne na další scénu/metodu</li>
<li>"p" - přepne na předcházející scénu/metodu</li>
<li>"esc" - konec</li>
</ul>
<h1><a class="anchor" id="testovani"></a>
Testování</h1>
<p>Vaši implementaci si můžete ověřit sadou vestavěných akceptačních testů. Když aplikaci pustíte s parametrem "-c", pustí se akceptační testy, které ověřují funkčnost vaší implementace. </p><div class="fragment"><div class="line">./izgProject -c</div>
</div><!-- fragment --><p> Pokud není nějaký test splněn, vypíše se k němu komentář s informacemi, co je špatně. Testy jsou seřazeny a měly by se plnit postupně. Pokud chcete pustit jeden konkrétní test (třeba 13.), pusťte aplikaci s parametry "-c --test 13". </p><div class="fragment"><div class="line">./izgProject -c --test 13</div>
</div><!-- fragment --><p> Pokud chcete pustit všechny testy až po jeden konkrétní (třeba 5.), pusťte aplikaci s parametry "-c --up-to-test --test 5". </p><div class="fragment"><div class="line">./izgProject -c --test 5 --up-to-test</div>
</div><!-- fragment --><p> To je užitečné, když implementujete sekci, a chcete vědět, jestli jste něco zpětně nerozbili.<br  />
 Na konci výpisu testů se vám vypíše bodové hodnocení.</p>
<h1><a class="anchor" id="odevzdavani"></a>
Odevzdávání</h1>
<p>Odevzdejte <b>proj.zip</b>, který obsahuje jen soubory <a class="el" href="gpu_8cpp.html" title="This file contains implementation of gpu.">gpu.cpp</a> a <a class="el" href="prepareModel_8cpp.html" title="This file contains functions for model rendering.">prepareModel.cpp</a>, žádné složky.<br  />
 Můžete odevzdat částečné řešení, hodnotí se to, co jste odevzdali a kolik bodů vám to vypočetlo.<br  />
</p>
<p>Před odevzdáváním si zkontrolujte, že váš projekt lze přeložit na merlinovi.<br  />
 Pro ověření kompilace nemusíte na merlin kopírovat složku resources (je velká).<br  />
 Pokud si chcete na merlinovi ověřit i akceptační testy stačí zkopírovat jen resources/images/output.png a resources/models/fin.glb.<br  />
 Zkopirujte projekt na merlin a spusťte skript: <b>./merlinCompilationTest.sh</b>.<br  />
<br  />
 Odevzdávejte pouze soubory <a class="el" href="gpu_8cpp.html" title="This file contains implementation of gpu.">gpu.cpp</a>, <a class="el" href="prepareModel_8cpp.html" title="This file contains functions for model rendering.">prepareModel.cpp</a> Soubory zabalte do archivu proj.zip. Po rozbalení archivu se <b>NESMÍ</b> vytvořit žádná složka. Příkazy pro ověření na Linuxu: zip proj.zip <a class="el" href="gpu_8cpp.html" title="This file contains implementation of gpu.">gpu.cpp</a> <a class="el" href="prepareModel_8cpp.html" title="This file contains functions for model rendering.">prepareModel.cpp</a>, unzip proj.zip. Studenti pracují na řešení projektu samostatně a každý odevzdá své vlastní řešení. Poraďte si, ale řešení vypracujte samostatně! Žádné kopírování kódu! Nedávejte svůj projekt veřejně na github, gitlab, soureforge, pastebin, discord nebo jinam, tím se automaticky stávate plagiátory.<br  />
 Neposílejte svým kamarádům kódy. Možná jim věříte, že to neokopírují, ale divili byste se. Pak byste se dostali mezi plagiátory.</p>
<h1><a class="anchor" id="chyby"></a>
Časté chyby, které nedělejte</h1>
<ol>
<li>
student se mě nezeptá pokud neví, jak něco vyřešit. Ptejte se. Odpovím, pokud budu vědět. </li>
<li>
student neodevzdá korektně zabalené soubory. </li>
<li>
student si inkluduje nějake soubory z windows, třeba windows.h - to nedělejte, překlad musí fungovat na merlinovi. </li>
<li>
student si přibalí nějaké náhodné soubory s MAC - to nedělejte, překlad musí fungovat na merlinovi. </li>
<li>
min, max funkce si berete odnikud - vyzkoušejte, jestli vám jde překlad na merlinovi, nebo použijte glm::min, glm::max </li>
<li>
špatně pojmenovaný archiv při odevzdávání </li>
<li>
soubory navíc, nebo přejmenované soubory v odevzdaném archivu </li>
<li>
memory corruption, přistupujete do paměti, kam nemáte (na to je valgrind) </li>
<li>
student odevzdá soubory v nějakém exotickém archivu, rar, tar.gz, 7z, iso... </li>
<li>
student zkouší projekt na systemu, který nebyl ověřen (ověřeno to bylo na Linuxu, Windows by měl běžet, ale ...). </li>
<li>
VirtualBox s Ubuntu je +- možný, ale může se narazit na SDL chybu no video device (asi je potřeba nainstalovat SDL: sudo apt install xorg-dev libx11-dev libgl1-mesa-glx). </li>
<li>
Nějaký problém se CMake a zprovoznením překladu na Windows (většinou je problém s cestami, zkuste dát projekt někam do jednoduché složky C:). </li>
<li>
Projekt máte příliš pomalý a tak jej automatické testy předčasně utnou. </li>
</ol>
<h1><a class="anchor" id="hodnoceni"></a>
Hodnocení</h1>
<p>Množství bodů, které dostanete, je odvozeno od množství splněných akceptačních testů a podle toho, zda vám to kreslí správně (s jistou tolerancí kvůli nepřesnosti floatové aritmetiky). Automatické opravování má k dispozici větší množství akceptačních testů (kdyby někoho napadlo je obejít). Pokud vám aplikace spadne v rámci testů, dostanete 0 bodů. Pokud aplikace nepůjde přeložit, dostanete 0 bodů.</p>
<h1><a class="anchor" id="soutez"></a>
Soutěž</h1>
<p>Pokud váš projekt obdrží plný počet bodů, bude zařazen do soutěže o nejrychlejší implementaci zobrazovacího řetězce. Můžete přeimplementovat cokoliv v odevzdávaných souborech pokud to projde akceptačními testy a kompilací.<br  />
 Spuštění měření výkonnosti: </p><div class="fragment"><div class="line">./izgProject -p -f 10</div>
</div><!-- fragment --><p> Nejrychlejší projekty budou na věčné časy zařazeny do <a href="https://www.fit.vutbr.cz/~imilet/shared/sinSlavy/">síně slávy</a>. A...<br  />
 <b>Ceny za 1., 2. a třetí místo v roce 2023 byly:</b> <br  />
 </p><div class="image">
<img src="plague.png" alt=""/>
</div>
 <div class="image">
<img src="hellblade.png" alt=""/>
</div>
 <div class="image">
<img src="pillars.png" alt=""/>
</div>
<p><b>Cena za nejrychlejší projekt v roce 2024 bude:</b> <br  />
 ????</p>
<h1><a class="anchor" id="zaver"></a>
Závěrem</h1>
<p>Ať se dílo daří a ať vás grafika alespoň trochu baví! V případě potřeby se nebojte zeptat (napište přímo vedoucímu projektu <a href="#" onclick="location.href='mai'+'lto:'+'imi'+'le'+'t@f'+'it'+'.vu'+'tb'+'r.c'+'z'; return false;">imile<span style="display: none;">.nosp@m.</span>t@fi<span style="display: none;">.nosp@m.</span>t.vut<span style="display: none;">.nosp@m.</span>br.c<span style="display: none;">.nosp@m.</span>z</a> nebojte se napsat, nekoušu. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="ttc" id="afwd_8hpp_html_a862161defe984b09e24dfec9e0540a3e"><div class="ttname"><a href="fwd_8hpp.html#a862161defe984b09e24dfec9e0540a3e">IndexType</a></div><div class="ttdeci">IndexType</div><div class="ttdoc">[Uniform]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:169</div></div>
<div class="ttc" id="astructFramebuffer_html_a5227afe8482c1670d87d34cf61ec08da"><div class="ttname"><a href="structFramebuffer.html#a5227afe8482c1670d87d34cf61ec08da">Framebuffer::yReversed</a></div><div class="ttdeci">bool yReversed</div><div class="ttdoc">is y axis flipped?</div><div class="ttdef"><b>Definition:</b> fwd.hpp:299</div></div>
<div class="ttc" id="aunionUniform_html_a8449fdf21a57c7e30991794dd81c3b74"><div class="ttname"><a href="unionUniform.html#a8449fdf21a57c7e30991794dd81c3b74">Uniform::i1</a></div><div class="ttdeci">int32_t i1</div><div class="ttdoc">single 32bit int</div><div class="ttdef"><b>Definition:</b> fwd.hpp:157</div></div>
<div class="ttc" id="astructProgram_html_a5b48bbf6bc459552b066757369a0f86d"><div class="ttname"><a href="structProgram.html#a5b48bbf6bc459552b066757369a0f86d">Program::vs2fs</a></div><div class="ttdeci">AttributeType vs2fs[maxAttributes]</div><div class="ttdoc">which attributes are interpolated from vertex shader to fragment shader</div><div class="ttdef"><b>Definition:</b> fwd.hpp:254</div></div>
<div class="ttc" id="astructShaderInterface_html"><div class="ttname"><a href="structShaderInterface.html">ShaderInterface</a></div><div class="ttdoc">[IndexType]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:185</div></div>
<div class="ttc" id="astructNode_html"><div class="ttname"><a href="structNode.html">Node</a></div><div class="ttdoc">[Mesh]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:618</div></div>
<div class="ttc" id="aunionAttribute_html_a7e4149eff36adcf056cb7153bfbf4c8c"><div class="ttname"><a href="unionAttribute.html#a7e4149eff36adcf056cb7153bfbf4c8c">Attribute::v3</a></div><div class="ttdeci">glm::vec3 v3</div><div class="ttdoc">vector of three floats</div><div class="ttdef"><b>Definition:</b> fwd.hpp:94</div></div>
<div class="ttc" id="afwd_8hpp_html_a21e038f5b8958e203d28bc4f18472352ac9e3011a04cc978bf737d10d2b73f4b7"><div class="ttname"><a href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352ac9e3011a04cc978bf737d10d2b73f4b7">CommandType::BIND_FRAMEBUFFER</a></div><div class="ttdeci">@ BIND_FRAMEBUFFER</div><div class="ttdoc">bind framebuffer command</div></div>
<div class="ttc" id="astructSubCommand_html"><div class="ttname"><a href="structSubCommand.html">SubCommand</a></div><div class="ttdoc">[BindVertexArrayCommand]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:422</div></div>
<div class="ttc" id="astructGPUMemory_html_a9b333f6f69347068f349d05961c7bf39"><div class="ttname"><a href="structGPUMemory.html#a9b333f6f69347068f349d05961c7bf39">GPUMemory::GPUMemory</a></div><div class="ttdeci">GPUMemory()</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition:</b> fwd.cpp:15</div></div>
<div class="ttc" id="afwd_8hpp_html_addfd10ead04eeadec78064481a4a3f4d"><div class="ttname"><a href="fwd_8hpp.html#addfd10ead04eeadec78064481a4a3f4d">AttributeType</a></div><div class="ttdeci">AttributeType</div><div class="ttdoc">[Texture]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:73</div></div>
<div class="ttc" id="astructMesh_html_ad0ab81099a4d195182afafa8c03c8371"><div class="ttname"><a href="structMesh.html#ad0ab81099a4d195182afafa8c03c8371">Mesh::diffuseTexture</a></div><div class="ttdeci">int diffuseTexture</div><div class="ttdoc">diffuse texture or -1 (no texture)</div><div class="ttdef"><b>Definition:</b> fwd.hpp:609</div></div>
<div class="ttc" id="astructMesh_html_a6ee7d4182d7a50b63cafca5b0b66c715"><div class="ttname"><a href="structMesh.html#a6ee7d4182d7a50b63cafca5b0b66c715">Mesh::indexBufferID</a></div><div class="ttdeci">int32_t indexBufferID</div><div class="ttdoc">index of buffer used for indices</div><div class="ttdef"><b>Definition:</b> fwd.hpp:601</div></div>
<div class="ttc" id="astructModel_html_a6797d253b3c7ca6f90a99d1b7abd0b79"><div class="ttname"><a href="structModel.html#a6797d253b3c7ca6f90a99d1b7abd0b79">Model::meshes</a></div><div class="ttdeci">std::vector&lt; Mesh &gt; meshes</div><div class="ttdoc">list of all meshes in model</div><div class="ttdef"><b>Definition:</b> fwd.hpp:630</div></div>
<div class="ttc" id="astructGPUMemory_html_a21eab797fb058f9cc8ceb26d5993f018"><div class="ttname"><a href="structGPUMemory.html#a21eab797fb058f9cc8ceb26d5993f018">GPUMemory::uniforms</a></div><div class="ttdeci">Uniform * uniforms</div><div class="ttdoc">array of all uniform variables</div><div class="ttdef"><b>Definition:</b> fwd.hpp:330</div></div>
<div class="ttc" id="astructBindFramebufferCommand_html"><div class="ttname"><a href="structBindFramebufferCommand.html">BindFramebufferCommand</a></div><div class="ttdoc">[SetDrawIdCommand]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:392</div></div>
<div class="ttc" id="astructBuffer_html"><div class="ttname"><a href="structBuffer.html">Buffer</a></div><div class="ttdoc">[Framebuffer]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:308</div></div>
<div class="ttc" id="aprepareModel_8cpp_html_af46f2952d390459f20fc55a1eb8f4f30"><div class="ttname"><a href="prepareModel_8cpp.html#af46f2952d390459f20fc55a1eb8f4f30">prepareModel</a></div><div class="ttdeci">void prepareModel(GPUMemory &amp;mem, CommandBuffer &amp;commandBuffer, Model const &amp;model)</div><div class="ttdoc">This function prepares model into memory and creates command buffer.</div><div class="ttdef"><b>Definition:</b> prepareModel.cpp:20</div></div>
<div class="ttc" id="astructInVertex_html_aa4d31911053492bffe4b41dae12ee000"><div class="ttname"><a href="structInVertex.html#aa4d31911053492bffe4b41dae12ee000">InVertex::gl_VertexID</a></div><div class="ttdeci">uint32_t gl_VertexID</div><div class="ttdoc">vertex id</div><div class="ttdef"><b>Definition:</b> fwd.hpp:109</div></div>
<div class="ttc" id="astructFramebuffer_html_aaaf692c4a3881fdd17df05c0d9b0811f"><div class="ttname"><a href="structFramebuffer.html#aaaf692c4a3881fdd17df05c0d9b0811f">Framebuffer::color</a></div><div class="ttdeci">Image color</div><div class="ttdoc">color buffer</div><div class="ttdef"><b>Definition:</b> fwd.hpp:295</div></div>
<div class="ttc" id="afwd_8hpp_html_a4a3d1b76496eeb849f86584b59091f7a"><div class="ttname"><a href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a></div><div class="ttdeci">const uint32_t maxAttributes</div><div class="ttdoc">maximum number of vertex/fragment attributes</div><div class="ttdef"><b>Definition:</b> fwd.hpp:16</div></div>
<div class="ttc" id="astructOutVertex_html_ad1d48203a36e3ee510841f25a5bc068e"><div class="ttname"><a href="structOutVertex.html#ad1d48203a36e3ee510841f25a5bc068e">OutVertex::attributes</a></div><div class="ttdeci">Attribute attributes[maxAttributes]</div><div class="ttdoc">vertex attributes</div><div class="ttdef"><b>Definition:</b> fwd.hpp:118</div></div>
<div class="ttc" id="afwd_8hpp_html_aaf908caefd690c7d905eb3baa9e1a569"><div class="ttname"><a href="fwd_8hpp.html#aaf908caefd690c7d905eb3baa9e1a569">pushBindFramebufferCommand</a></div><div class="ttdeci">void pushBindFramebufferCommand(CommandBuffer &amp;cb, uint32_t id)</div><div class="ttdoc">This function can be used to insert bindFramebuffer command into command buffer.</div><div class="ttdef"><b>Definition:</b> fwd.hpp:532</div></div>
<div class="ttc" id="astructGPUMemory_html_acab4bb492d24e78131d39ea7997266cb"><div class="ttname"><a href="structGPUMemory.html#acab4bb492d24e78131d39ea7997266cb">GPUMemory::vertexArrays</a></div><div class="ttdeci">VertexArray * vertexArrays</div><div class="ttdoc">array of all vertex arrays</div><div class="ttdef"><b>Definition:</b> fwd.hpp:333</div></div>
<div class="ttc" id="astructBuffer_html_a3d37b3ab0942c1222347f8de7520f9ef"><div class="ttname"><a href="structBuffer.html#a3d37b3ab0942c1222347f8de7520f9ef">Buffer::size</a></div><div class="ttdeci">uint64_t size</div><div class="ttdoc">size of data in bytes</div><div class="ttdef"><b>Definition:</b> fwd.hpp:310</div></div>
<div class="ttc" id="astructGPUMemory_html_aa73d331b9be494e550928fad4ac6c23d"><div class="ttname"><a href="structGPUMemory.html#aa73d331b9be494e550928fad4ac6c23d">GPUMemory::maxUniforms</a></div><div class="ttdeci">uint32_t maxUniforms</div><div class="ttdoc">maximal number of uniforms</div><div class="ttdef"><b>Definition:</b> fwd.hpp:321</div></div>
<div class="ttc" id="astructVertexAttrib_html"><div class="ttname"><a href="structVertexAttrib.html">VertexAttrib</a></div><div class="ttdoc">[FragmentShader]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:224</div></div>
<div class="ttc" id="afwd_8hpp_html_addfd10ead04eeadec78064481a4a3f4daee190f7a0572504036effa0134dc5d88"><div class="ttname"><a href="fwd_8hpp.html#addfd10ead04eeadec78064481a4a3f4daee190f7a0572504036effa0134dc5d88">AttributeType::VEC4</a></div><div class="ttdeci">@ VEC4</div><div class="ttdoc">4x 32-bit floats</div></div>
<div class="ttc" id="aunionCommandData_html_a65398ff2cc6bd213bcbd8ac5cff5f734"><div class="ttname"><a href="unionCommandData.html#a65398ff2cc6bd213bcbd8ac5cff5f734">CommandData::setDrawIdCommand</a></div><div class="ttdeci">SetDrawIdCommand setDrawIdCommand</div><div class="ttdoc">set drawId command</div><div class="ttdef"><b>Definition:</b> fwd.hpp:451</div></div>
<div class="ttc" id="astructBuffer_html_a8fbe8b3fba53c8ff7fcd44f9c4f463c7"><div class="ttname"><a href="structBuffer.html#a8fbe8b3fba53c8ff7fcd44f9c4f463c7">Buffer::data</a></div><div class="ttdeci">void const  * data</div><div class="ttdoc">pointer to data</div><div class="ttdef"><b>Definition:</b> fwd.hpp:309</div></div>
<div class="ttc" id="astructClearCommand_html_a2a045bebfafe570f67eafdeb7ece7779"><div class="ttname"><a href="structClearCommand.html#a2a045bebfafe570f67eafdeb7ece7779">ClearCommand::depth</a></div><div class="ttdeci">float depth</div><div class="ttdoc">depth buffer will be cleared by this value</div><div class="ttdef"><b>Definition:</b> fwd.hpp:360</div></div>
<div class="ttc" id="astructCommandBuffer_html_a94aad407c5115fdcd040134eef20b76b"><div class="ttname"><a href="structCommandBuffer.html#a94aad407c5115fdcd040134eef20b76b">CommandBuffer::maxCommands</a></div><div class="ttdeci">static const uint32_t maxCommands</div><div class="ttdoc">maximal number of commands</div><div class="ttdef"><b>Definition:</b> fwd.hpp:476</div></div>
<div class="ttc" id="astructSubCommand_html_a6743a1b924763618d8c2fafd3b4decd5"><div class="ttname"><a href="structSubCommand.html#a6743a1b924763618d8c2fafd3b4decd5">SubCommand::commandBuffer</a></div><div class="ttdeci">CommandBuffer * commandBuffer</div><div class="ttdoc">pointer to secondary command buffer</div><div class="ttdef"><b>Definition:</b> fwd.hpp:423</div></div>
<div class="ttc" id="astructGPUMemory_html_aa8e57983bda33e4ef48e825d5bf261eb"><div class="ttname"><a href="structGPUMemory.html#aa8e57983bda33e4ef48e825d5bf261eb">GPUMemory::maxPrograms</a></div><div class="ttdeci">uint32_t maxPrograms</div><div class="ttdoc">maximal number of programs</div><div class="ttdef"><b>Definition:</b> fwd.hpp:325</div></div>
<div class="ttc" id="astructFramebuffer_html_ad56ef80596abe229e99657865ae8a79b"><div class="ttname"><a href="structFramebuffer.html#ad56ef80596abe229e99657865ae8a79b">Framebuffer::depth</a></div><div class="ttdeci">Image depth</div><div class="ttdoc">depth buffer</div><div class="ttdef"><b>Definition:</b> fwd.hpp:296</div></div>
<div class="ttc" id="astructModel_html_ace109d8eec99777f72694b7d49b2224f"><div class="ttname"><a href="structModel.html#ace109d8eec99777f72694b7d49b2224f">Model::textures</a></div><div class="ttdeci">std::vector&lt; Texture &gt; textures</div><div class="ttdoc">list of all textures in model</div><div class="ttdef"><b>Definition:</b> fwd.hpp:632</div></div>
<div class="ttc" id="astructImage_html_a86d38f6adc2c4bc8285c908460634eac"><div class="ttname"><a href="structImage.html#a86d38f6adc2c4bc8285c908460634eac">Image::channelTypes</a></div><div class="ttdeci">Channel channelTypes[4]</div><div class="ttdoc">only for colors - what colors the channels represent</div><div class="ttdef"><b>Definition:</b> fwd.hpp:51</div></div>
<div class="ttc" id="astructDrawCommand_html_aff1a6f40fd082c3a0065b5fa3998a753"><div class="ttname"><a href="structDrawCommand.html#aff1a6f40fd082c3a0065b5fa3998a753">DrawCommand::backfaceCulling</a></div><div class="ttdeci">bool backfaceCulling</div><div class="ttdoc">is culling of backfacing triangles enabled?</div><div class="ttdef"><b>Definition:</b> fwd.hpp:373</div></div>
<div class="ttc" id="astructMesh_html_ad60502867a78d6e442172d1ea5b679d6"><div class="ttname"><a href="structMesh.html#ad60502867a78d6e442172d1ea5b679d6">Mesh::nofIndices</a></div><div class="ttdeci">uint32_t nofIndices</div><div class="ttdoc">nofIndices or nofVertices (if there is no indexing)</div><div class="ttdef"><b>Definition:</b> fwd.hpp:607</div></div>
<div class="ttc" id="astructMesh_html"><div class="ttname"><a href="structMesh.html">Mesh</a></div><div class="ttdoc">This struct represents a mesh.</div><div class="ttdef"><b>Definition:</b> fwd.hpp:600</div></div>
<div class="ttc" id="astructNode_html_ad4e3fcf9fdbd325a83e87cfb7ab86554"><div class="ttname"><a href="structNode.html#ad4e3fcf9fdbd325a83e87cfb7ab86554">Node::mesh</a></div><div class="ttdeci">int32_t mesh</div><div class="ttdoc">id of mesh or -1 if no mesh</div><div class="ttdef"><b>Definition:</b> fwd.hpp:620</div></div>
<div class="ttc" id="astructTexture_html_a64d1fdc3117ab704bc4c4c9696d7237e"><div class="ttname"><a href="structTexture.html#a64d1fdc3117ab704bc4c4c9696d7237e">Texture::img</a></div><div class="ttdeci">Image img</div><div class="ttdoc">image</div><div class="ttdef"><b>Definition:</b> fwd.hpp:62</div></div>
<div class="ttc" id="aunionAttribute_html_a9ccf454d347d4fabf4e89207f01812b1"><div class="ttname"><a href="unionAttribute.html#a9ccf454d347d4fabf4e89207f01812b1">Attribute::u4</a></div><div class="ttdeci">glm::uvec4 u4</div><div class="ttdoc">vector of four unsigned ints</div><div class="ttdef"><b>Definition:</b> fwd.hpp:99</div></div>
<div class="ttc" id="astructImage_html"><div class="ttname"><a href="structImage.html">Image</a></div><div class="ttdoc">This structure represents 2D memory of image. 2D images are used as textures and color or depth buffe...</div><div class="ttdef"><b>Definition:</b> fwd.hpp:31</div></div>
<div class="ttc" id="astructOutFragment_html_a9670bf5a31a5c23fccdbeaad959cc3cf"><div class="ttname"><a href="structOutFragment.html#a9670bf5a31a5c23fccdbeaad959cc3cf">OutFragment::gl_FragColor</a></div><div class="ttdeci">glm::vec4 gl_FragColor</div><div class="ttdoc">fragment color</div><div class="ttdef"><b>Definition:</b> fwd.hpp:138</div></div>
<div class="ttc" id="afwd_8hpp_html_a6a83b6ff420e4e17a9aef5a4a11a2499"><div class="ttname"><a href="fwd_8hpp.html#a6a83b6ff420e4e17a9aef5a4a11a2499">pushBindVertexArrayCommand</a></div><div class="ttdeci">void pushBindVertexArrayCommand(CommandBuffer &amp;cb, uint32_t id)</div><div class="ttdoc">This function inserts bindVertexArray command into command buffer.</div><div class="ttdef"><b>Definition:</b> fwd.hpp:560</div></div>
<div class="ttc" id="aunionAttribute_html_af2690c24c27269bea60eb0dff02c6861"><div class="ttname"><a href="unionAttribute.html#af2690c24c27269bea60eb0dff02c6861">Attribute::u3</a></div><div class="ttdeci">glm::uvec3 u3</div><div class="ttdoc">vector of three unsigned ints</div><div class="ttdef"><b>Definition:</b> fwd.hpp:98</div></div>
<div class="ttc" id="afwd_8hpp_html_a21e038f5b8958e203d28bc4f18472352ac539ee5fafd5847e0877fc545dde6093"><div class="ttname"><a href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352ac539ee5fafd5847e0877fc545dde6093">CommandType::BIND_PROGRAM</a></div><div class="ttdeci">@ BIND_PROGRAM</div><div class="ttdoc">bind program command</div></div>
<div class="ttc" id="astructImage_html_a1d53cd4fd9e5b67d38d49bc2c5ebd0db"><div class="ttname"><a href="structImage.html#a1d53cd4fd9e5b67d38d49bc2c5ebd0db">Image::Format</a></div><div class="ttdeci">Format</div><div class="ttdoc">Format of data.</div><div class="ttdef"><b>Definition:</b> fwd.hpp:44</div></div>
<div class="ttc" id="afwd_8hpp_html_a862161defe984b09e24dfec9e0540a3ea48d8f1a723d44ff4a87db1bb6c551c62"><div class="ttname"><a href="fwd_8hpp.html#a862161defe984b09e24dfec9e0540a3ea48d8f1a723d44ff4a87db1bb6c551c62">IndexType::UINT16</a></div><div class="ttdeci">@ UINT16</div><div class="ttdoc">uin16_t type</div></div>
<div class="ttc" id="astructOutVertex_html"><div class="ttname"><a href="structOutVertex.html">OutVertex</a></div><div class="ttdoc">[InVertex]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:117</div></div>
<div class="ttc" id="afwd_8hpp_html_a862161defe984b09e24dfec9e0540a3eaecfc091ed2a607335524c8389cfa41b5"><div class="ttname"><a href="fwd_8hpp.html#a862161defe984b09e24dfec9e0540a3eaecfc091ed2a607335524c8389cfa41b5">IndexType::UINT8</a></div><div class="ttdeci">@ UINT8</div><div class="ttdoc">uin8_t type</div></div>
<div class="ttc" id="astructShaderInterface_html_ad33e6e9e4ff2fbf3853b4430f05188cb"><div class="ttname"><a href="structShaderInterface.html#ad33e6e9e4ff2fbf3853b4430f05188cb">ShaderInterface::textures</a></div><div class="ttdeci">Texture const  * textures</div><div class="ttdoc">textures</div><div class="ttdef"><b>Definition:</b> fwd.hpp:187</div></div>
<div class="ttc" id="astructGPUMemory_html_a4755d327262c8020766718bb31f92d0b"><div class="ttname"><a href="structGPUMemory.html#a4755d327262c8020766718bb31f92d0b">GPUMemory::buffers</a></div><div class="ttdeci">Buffer * buffers</div><div class="ttdoc">array of all buffers</div><div class="ttdef"><b>Definition:</b> fwd.hpp:328</div></div>
<div class="ttc" id="afwd_8hpp_html_a21e038f5b8958e203d28bc4f18472352af33727905f5b6f48cac50cb735ed9524"><div class="ttname"><a href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352af33727905f5b6f48cac50cb735ed9524">CommandType::SET_DRAW_ID</a></div><div class="ttdeci">@ SET_DRAW_ID</div><div class="ttdoc">set drawId command</div></div>
<div class="ttc" id="astructModel_html_ac1fcef5b98a4c88e5fec3672180e85f1"><div class="ttname"><a href="structModel.html#ac1fcef5b98a4c88e5fec3672180e85f1">Model::roots</a></div><div class="ttdeci">std::vector&lt; Node &gt; roots</div><div class="ttdoc">list of roots of node trees</div><div class="ttdef"><b>Definition:</b> fwd.hpp:631</div></div>
<div class="ttc" id="astructVertexAttrib_html_a4578d3605e0f61b7bfd1f5e24df7c9bf"><div class="ttname"><a href="structVertexAttrib.html#a4578d3605e0f61b7bfd1f5e24df7c9bf">VertexAttrib::bufferID</a></div><div class="ttdeci">int32_t bufferID</div><div class="ttdoc">buffer id</div><div class="ttdef"><b>Definition:</b> fwd.hpp:225</div></div>
<div class="ttc" id="astructImage_html_a85765e057e50aaa2da6ffd1e7085f52a"><div class="ttname"><a href="structImage.html#a85765e057e50aaa2da6ffd1e7085f52a">Image::pitch</a></div><div class="ttdeci">uint32_t pitch</div><div class="ttdoc">size of row in bytes</div><div class="ttdef"><b>Definition:</b> fwd.hpp:52</div></div>
<div class="ttc" id="astructGPUMemory_html_a0be973077c6d15f40e31d0781b1ea8e6"><div class="ttname"><a href="structGPUMemory.html#a0be973077c6d15f40e31d0781b1ea8e6">GPUMemory::maxBuffers</a></div><div class="ttdeci">uint32_t maxBuffers</div><div class="ttdoc">maximal number of buffers</div><div class="ttdef"><b>Definition:</b> fwd.hpp:324</div></div>
<div class="ttc" id="aunionUniform_html_ad2afb58e290202cd23e444440e1b1f07"><div class="ttname"><a href="unionUniform.html#ad2afb58e290202cd23e444440e1b1f07">Uniform::v4</a></div><div class="ttdeci">glm::vec4 v4</div><div class="ttdoc">four floats</div><div class="ttdef"><b>Definition:</b> fwd.hpp:152</div></div>
<div class="ttc" id="afwd_8hpp_html_a21e038f5b8958e203d28bc4f18472352af579b0c380b4a2da14f78e233e2a44f6"><div class="ttname"><a href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352af579b0c380b4a2da14f78e233e2a44f6">CommandType::BIND_VERTEXARRAY</a></div><div class="ttdeci">@ BIND_VERTEXARRAY</div><div class="ttdoc">bind vertex array command</div></div>
<div class="ttc" id="afwd_8hpp_html_addfd10ead04eeadec78064481a4a3f4daa7c116def9f212182aa52ab1e936d77d"><div class="ttname"><a href="fwd_8hpp.html#addfd10ead04eeadec78064481a4a3f4daa7c116def9f212182aa52ab1e936d77d">AttributeType::VEC3</a></div><div class="ttdeci">@ VEC3</div><div class="ttdoc">3x 32-bit floats</div></div>
<div class="ttc" id="astructMesh_html_a12235d3eae977558b64d1f5ec3022db7"><div class="ttname"><a href="structMesh.html#a12235d3eae977558b64d1f5ec3022db7">Mesh::diffuseColor</a></div><div class="ttdeci">glm::vec4 diffuseColor</div><div class="ttdoc">default diffuseColor (if there is no texture)</div><div class="ttdef"><b>Definition:</b> fwd.hpp:608</div></div>
<div class="ttc" id="astructCommand_html"><div class="ttname"><a href="structCommand.html">Command</a></div><div class="ttdoc">[CommandData]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:463</div></div>
<div class="ttc" id="astructProgram_html_a2bcea678985527f04a87be358ff1f78b"><div class="ttname"><a href="structProgram.html#a2bcea678985527f04a87be358ff1f78b">Program::vertexShader</a></div><div class="ttdeci">VertexShader vertexShader</div><div class="ttdoc">vertex shader</div><div class="ttdef"><b>Definition:</b> fwd.hpp:252</div></div>
<div class="ttc" id="afwd_8hpp_html_a21e038f5b8958e203d28bc4f18472352aba2b45bdc11e2a4a6e86aab2ac693cbb"><div class="ttname"><a href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352aba2b45bdc11e2a4a6e86aab2ac693cbb">CommandType::EMPTY</a></div><div class="ttdeci">@ EMPTY</div><div class="ttdoc">empty command</div></div>
<div class="ttc" id="astructTexture_html_a35691eb813ceb8467b436092b1c9d8ed"><div class="ttname"><a href="structTexture.html#a35691eb813ceb8467b436092b1c9d8ed">Texture::height</a></div><div class="ttdeci">uint32_t height</div><div class="ttdoc">height of the texture</div><div class="ttdef"><b>Definition:</b> fwd.hpp:64</div></div>
<div class="ttc" id="aunionAttribute_html_ac47131c7c30814e28f0c4662a4ed2737"><div class="ttname"><a href="unionAttribute.html#ac47131c7c30814e28f0c4662a4ed2737">Attribute::v4</a></div><div class="ttdeci">glm::vec4 v4</div><div class="ttdoc">vector of four floats</div><div class="ttdef"><b>Definition:</b> fwd.hpp:95</div></div>
<div class="ttc" id="astructDrawCommand_html_a4a7376486faf9f07fccb7de82d86566b"><div class="ttname"><a href="structDrawCommand.html#a4a7376486faf9f07fccb7de82d86566b">DrawCommand::nofVertices</a></div><div class="ttdeci">uint32_t nofVertices</div><div class="ttdoc">number of vertices to draw</div><div class="ttdef"><b>Definition:</b> fwd.hpp:372</div></div>
<div class="ttc" id="astructProgram_html_a5faf623d0af27d6000ebcacafecf2eb5"><div class="ttname"><a href="structProgram.html#a5faf623d0af27d6000ebcacafecf2eb5">Program::fragmentShader</a></div><div class="ttdeci">FragmentShader fragmentShader</div><div class="ttdoc">fragment shader</div><div class="ttdef"><b>Definition:</b> fwd.hpp:253</div></div>
<div class="ttc" id="aunionCommandData_html_a160c967b3ad7619a90a4d40ace1d806e"><div class="ttname"><a href="unionCommandData.html#a160c967b3ad7619a90a4d40ace1d806e">CommandData::drawCommand</a></div><div class="ttdeci">DrawCommand drawCommand</div><div class="ttdoc">draw command data</div><div class="ttdef"><b>Definition:</b> fwd.hpp:450</div></div>
<div class="ttc" id="astructCommand_html_afd23b7e189739dbae6c0f2e93ba02c81"><div class="ttname"><a href="structCommand.html#afd23b7e189739dbae6c0f2e93ba02c81">Command::type</a></div><div class="ttdeci">CommandType type</div><div class="ttdoc">type of the command</div><div class="ttdef"><b>Definition:</b> fwd.hpp:465</div></div>
<div class="ttc" id="astructShaderInterface_html_a03009720e763e8efe2bfa4d4607dcc10"><div class="ttname"><a href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">ShaderInterface::uniforms</a></div><div class="ttdeci">Uniform const  * uniforms</div><div class="ttdoc">uniform variables</div><div class="ttdef"><b>Definition:</b> fwd.hpp:186</div></div>
<div class="ttc" id="aunionAttribute_html_aa240c263ec02c39b48d662a1c598e1fc"><div class="ttname"><a href="unionAttribute.html#aa240c263ec02c39b48d662a1c598e1fc">Attribute::v2</a></div><div class="ttdeci">glm::vec2 v2</div><div class="ttdoc">vector of two floats</div><div class="ttdef"><b>Definition:</b> fwd.hpp:93</div></div>
<div class="ttc" id="astructVertexArray_html_a7648ec169177dbb70b495b51ffcfb606"><div class="ttname"><a href="structVertexArray.html#a7648ec169177dbb70b495b51ffcfb606">VertexArray::indexBufferID</a></div><div class="ttdeci">int32_t indexBufferID</div><div class="ttdoc">id of index buffer</div><div class="ttdef"><b>Definition:</b> fwd.hpp:239</div></div>
<div class="ttc" id="astructGPUMemory_html_abd0d80589104a936db46ae766bc7975e"><div class="ttname"><a href="structGPUMemory.html#abd0d80589104a936db46ae766bc7975e">GPUMemory::framebuffers</a></div><div class="ttdeci">Framebuffer * framebuffers</div><div class="ttdoc">framebuffer - output of rendering, 0 is default framebuffer</div><div class="ttdef"><b>Definition:</b> fwd.hpp:332</div></div>
<div class="ttc" id="aunionUniform_html_a2714f4ff3e6703bccdac2c92dcad3b25"><div class="ttname"><a href="unionUniform.html#a2714f4ff3e6703bccdac2c92dcad3b25">Uniform::v1</a></div><div class="ttdeci">float v1</div><div class="ttdoc">single float</div><div class="ttdef"><b>Definition:</b> fwd.hpp:149</div></div>
<div class="ttc" id="astructGPUMemory_html_a59c169462c028204dfca9b92f5cd9230"><div class="ttname"><a href="structGPUMemory.html#a59c169462c028204dfca9b92f5cd9230">GPUMemory::operator=</a></div><div class="ttdeci">GPUMemory &amp; operator=(GPUMemory const &amp;o)</div><div class="ttdoc">Assign operator.</div><div class="ttdef"><b>Definition:</b> fwd.cpp:53</div></div>
<div class="ttc" id="astructVertexAttrib_html_a58f3129f893d0ce72ec7d364fef21840"><div class="ttname"><a href="structVertexAttrib.html#a58f3129f893d0ce72ec7d364fef21840">VertexAttrib::offset</a></div><div class="ttdeci">uint64_t offset</div><div class="ttdoc">offset in bytes</div><div class="ttdef"><b>Definition:</b> fwd.hpp:227</div></div>
<div class="ttc" id="astructGPUMemory_html_aa6541055bfd7af94a91f35bfe0cd9aad"><div class="ttname"><a href="structGPUMemory.html#aa6541055bfd7af94a91f35bfe0cd9aad">GPUMemory::gl_DrawID</a></div><div class="ttdeci">uint32_t gl_DrawID</div><div class="ttdoc">draw call id</div><div class="ttdef"><b>Definition:</b> fwd.hpp:337</div></div>
<div class="ttc" id="afwd_8hpp_html_a8f837089b3ff5f5c2ebc125f4000fdd4"><div class="ttname"><a href="fwd_8hpp.html#a8f837089b3ff5f5c2ebc125f4000fdd4">pushClearCommand</a></div><div class="ttdeci">void pushClearCommand(CommandBuffer &amp;cb, glm::vec4 const &amp;color=glm::vec4(0), float depth=10e10, bool clearColor=true, bool clearDepth=true)</div><div class="ttdoc">[CommandBuffer]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:491</div></div>
<div class="ttc" id="astructCommandBuffer_html_addba1f7b3ffb5ad52a484d1b815436df"><div class="ttname"><a href="structCommandBuffer.html#addba1f7b3ffb5ad52a484d1b815436df">CommandBuffer::commands</a></div><div class="ttdeci">Command commands[maxCommands]</div><div class="ttdoc">array of commands</div><div class="ttdef"><b>Definition:</b> fwd.hpp:478</div></div>
<div class="ttc" id="astructClearCommand_html_a044a86c021e546d61cd21d24bb2bc3c5"><div class="ttname"><a href="structClearCommand.html#a044a86c021e546d61cd21d24bb2bc3c5">ClearCommand::clearDepth</a></div><div class="ttdeci">bool clearDepth</div><div class="ttdoc">is depth cleaning enabled?</div><div class="ttdef"><b>Definition:</b> fwd.hpp:362</div></div>
<div class="ttc" id="astructGPUMemory_html_aba0548cad16f8557782a5b2a409685b0"><div class="ttname"><a href="structGPUMemory.html#aba0548cad16f8557782a5b2a409685b0">GPUMemory::~GPUMemory</a></div><div class="ttdeci">~GPUMemory()</div><div class="ttdoc">Destructor.</div><div class="ttdef"><b>Definition:</b> fwd.cpp:61</div></div>
<div class="ttc" id="afwd_8hpp_html_a61e7df3fcaa53829be20be29b197e3e6"><div class="ttname"><a href="fwd_8hpp.html#a61e7df3fcaa53829be20be29b197e3e6">VertexShader</a></div><div class="ttdeci">void(*)(OutVertex &amp;outVertex, InVertex const  &amp;inVertex, ShaderInterface const  &amp;si) VertexShader</div><div class="ttdoc">[ShaderInterface]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:203</div></div>
<div class="ttc" id="agpu_8cpp_html_a688e2ccf23ad94434083e6ecb5709a16"><div class="ttname"><a href="gpu_8cpp.html#a688e2ccf23ad94434083e6ecb5709a16">read_textureClamp</a></div><div class="ttdeci">glm::vec4 read_textureClamp(Texture const &amp;texture, glm::vec2 uv)</div><div class="ttdoc">This function reads color from texture with clamping on the borders.</div><div class="ttdef"><b>Definition:</b> gpu.cpp:48</div></div>
<div class="ttc" id="astructVertexAttrib_html_a0b722b51b4528b50603e99722329d41a"><div class="ttname"><a href="structVertexAttrib.html#a0b722b51b4528b50603e99722329d41a">VertexAttrib::type</a></div><div class="ttdeci">AttributeType type</div><div class="ttdoc">type of attribute</div><div class="ttdef"><b>Definition:</b> fwd.hpp:228</div></div>
<div class="ttc" id="afwd_8hpp_html_a21e038f5b8958e203d28bc4f18472352aadcc01dbaca0f0d3fb64ef8f45550ec3"><div class="ttname"><a href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352aadcc01dbaca0f0d3fb64ef8f45550ec3">CommandType::SUB_COMMAND</a></div><div class="ttdeci">@ SUB_COMMAND</div><div class="ttdoc">sub command</div></div>
<div class="ttc" id="astructBindVertexArrayCommand_html"><div class="ttname"><a href="structBindVertexArrayCommand.html">BindVertexArrayCommand</a></div><div class="ttdoc">[BindProgramCommand]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:412</div></div>
<div class="ttc" id="astructTexture_html_a48c85d8e7c257d854238980f5bcc3b75"><div class="ttname"><a href="structTexture.html#a48c85d8e7c257d854238980f5bcc3b75">Texture::width</a></div><div class="ttdeci">uint32_t width</div><div class="ttdoc">width of the texture</div><div class="ttdef"><b>Definition:</b> fwd.hpp:63</div></div>
<div class="ttc" id="aunionUniform_html"><div class="ttname"><a href="unionUniform.html">Uniform</a></div><div class="ttdoc">[OutFragment]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:147</div></div>
<div class="ttc" id="aunionAttribute_html_a63c701e46c9ce4fb0e9494806769faa1"><div class="ttname"><a href="unionAttribute.html#a63c701e46c9ce4fb0e9494806769faa1">Attribute::u1</a></div><div class="ttdeci">uint32_t u1</div><div class="ttdoc">single unsigned int</div><div class="ttdef"><b>Definition:</b> fwd.hpp:96</div></div>
<div class="ttc" id="astructVertexArray_html_a7822420a93f7334ffdb1a0992de59ae3"><div class="ttname"><a href="structVertexArray.html#a7822420a93f7334ffdb1a0992de59ae3">VertexArray::indexType</a></div><div class="ttdeci">IndexType indexType</div><div class="ttdoc">type of indices</div><div class="ttdef"><b>Definition:</b> fwd.hpp:241</div></div>
<div class="ttc" id="afwd_8hpp_html_a862161defe984b09e24dfec9e0540a3ea17266551181f69a1b4a3ad5c9e270afc"><div class="ttname"><a href="fwd_8hpp.html#a862161defe984b09e24dfec9e0540a3ea17266551181f69a1b4a3ad5c9e270afc">IndexType::UINT32</a></div><div class="ttdeci">@ UINT32</div><div class="ttdoc">uint32_t type</div></div>
<div class="ttc" id="astructProgram_html"><div class="ttname"><a href="structProgram.html">Program</a></div><div class="ttdoc">[VertexArray]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:251</div></div>
<div class="ttc" id="astructMesh_html_a64c4b4488ba4d235f2b6e7c0e4d47cd7"><div class="ttname"><a href="structMesh.html#a64c4b4488ba4d235f2b6e7c0e4d47cd7">Mesh::texCoord</a></div><div class="ttdeci">VertexAttrib texCoord</div><div class="ttdoc">tex. coord vertex attribute</div><div class="ttdef"><b>Definition:</b> fwd.hpp:606</div></div>
<div class="ttc" id="astructDrawCommand_html"><div class="ttname"><a href="structDrawCommand.html">DrawCommand</a></div><div class="ttdoc">[ClearCommand]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:371</div></div>
<div class="ttc" id="astructImage_html_a2d9eabf3628b454331420e4b377538b9"><div class="ttname"><a href="structImage.html#a2d9eabf3628b454331420e4b377538b9">Image::data</a></div><div class="ttdeci">void * data</div><div class="ttdoc">point to image data</div><div class="ttdef"><b>Definition:</b> fwd.hpp:48</div></div>
<div class="ttc" id="aunionCommandData_html_a413e8640a4a2e25636d4042f8d781c3e"><div class="ttname"><a href="unionCommandData.html#a413e8640a4a2e25636d4042f8d781c3e">CommandData::bindFramebufferCommand</a></div><div class="ttdeci">BindFramebufferCommand bindFramebufferCommand</div><div class="ttdoc">bind framebuffer command</div><div class="ttdef"><b>Definition:</b> fwd.hpp:452</div></div>
<div class="ttc" id="astructClearCommand_html"><div class="ttname"><a href="structClearCommand.html">ClearCommand</a></div><div class="ttdoc">This structure represents clear command. Clear command stores data which are used by clearing operati...</div><div class="ttdef"><b>Definition:</b> fwd.hpp:358</div></div>
<div class="ttc" id="aunionCommandData_html_aa22d28e0590e0c57ec11a8184ea02d3c"><div class="ttname"><a href="unionCommandData.html#aa22d28e0590e0c57ec11a8184ea02d3c">CommandData::clearCommand</a></div><div class="ttdeci">ClearCommand clearCommand</div><div class="ttdoc">clear command data</div><div class="ttdef"><b>Definition:</b> fwd.hpp:449</div></div>
<div class="ttc" id="astructFramebuffer_html_ad2efd3ac1249da4ce70d478cd48d0e22"><div class="ttname"><a href="structFramebuffer.html#ad2efd3ac1249da4ce70d478cd48d0e22">Framebuffer::width</a></div><div class="ttdeci">uint32_t width</div><div class="ttdoc">width of frame buffer</div><div class="ttdef"><b>Definition:</b> fwd.hpp:297</div></div>
<div class="ttc" id="astructTexture_html"><div class="ttname"><a href="structTexture.html">Texture</a></div><div class="ttdoc">[Image]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:61</div></div>
<div class="ttc" id="astructImage_html_a98d0e7ac2ffeca933536b705cbdc5dba"><div class="ttname"><a href="structImage.html#a98d0e7ac2ffeca933536b705cbdc5dba">Image::format</a></div><div class="ttdeci">Format format</div><div class="ttdoc">type of data for every channel</div><div class="ttdef"><b>Definition:</b> fwd.hpp:50</div></div>
<div class="ttc" id="astructVertexArray_html"><div class="ttname"><a href="structVertexArray.html">VertexArray</a></div><div class="ttdoc">[VertexAttrib]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:237</div></div>
<div class="ttc" id="astructOutVertex_html_a9ca7de8eef8d688163497a7d34c76d7b"><div class="ttname"><a href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">OutVertex::gl_Position</a></div><div class="ttdeci">glm::vec4 gl_Position</div><div class="ttdoc">clip space position</div><div class="ttdef"><b>Definition:</b> fwd.hpp:119</div></div>
<div class="ttc" id="afwd_8hpp_html_a21e038f5b8958e203d28bc4f18472352a813461e0c58e7ad59a2fd83ca2237fec"><div class="ttname"><a href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352a813461e0c58e7ad59a2fd83ca2237fec">CommandType::CLEAR</a></div><div class="ttdeci">@ CLEAR</div><div class="ttdoc">clear command</div></div>
<div class="ttc" id="aunionCommandData_html_aef83fe6c79c6a7d82c142d9e965f0125"><div class="ttname"><a href="unionCommandData.html#aef83fe6c79c6a7d82c142d9e965f0125">CommandData::bindVertexArrayCommand</a></div><div class="ttdeci">BindVertexArrayCommand bindVertexArrayCommand</div><div class="ttdoc">bind vertex array command</div><div class="ttdef"><b>Definition:</b> fwd.hpp:454</div></div>
<div class="ttc" id="astructCommandBuffer_html_a5a4e731514b5998dad67189ca3612f3e"><div class="ttname"><a href="structCommandBuffer.html#a5a4e731514b5998dad67189ca3612f3e">CommandBuffer::nofCommands</a></div><div class="ttdeci">uint32_t nofCommands</div><div class="ttdoc">number of used commands in command buffer</div><div class="ttdef"><b>Definition:</b> fwd.hpp:477</div></div>
<div class="ttc" id="astructVertexAttrib_html_aef250d71bce43e96a6efb9180f24d079"><div class="ttname"><a href="structVertexAttrib.html#aef250d71bce43e96a6efb9180f24d079">VertexAttrib::stride</a></div><div class="ttdeci">uint64_t stride</div><div class="ttdoc">stride in bytes</div><div class="ttdef"><b>Definition:</b> fwd.hpp:226</div></div>
<div class="ttc" id="astructInFragment_html"><div class="ttname"><a href="structInFragment.html">InFragment</a></div><div class="ttdoc">[OutVertex]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:127</div></div>
<div class="ttc" id="astructGPUMemory_html_a7f32178fb1950dde77a2133bb93bbe5b"><div class="ttname"><a href="structGPUMemory.html#a7f32178fb1950dde77a2133bb93bbe5b">GPUMemory::defaultFramebuffer</a></div><div class="ttdeci">uint32_t defaultFramebuffer</div><div class="ttdoc">id of default framebuffer</div><div class="ttdef"><b>Definition:</b> fwd.hpp:327</div></div>
<div class="ttc" id="astructOutFragment_html_aa9b70f2f945e7b287321be9a1309f512"><div class="ttname"><a href="structOutFragment.html#aa9b70f2f945e7b287321be9a1309f512">OutFragment::discard</a></div><div class="ttdeci">bool discard</div><div class="ttdoc">discard fragment</div><div class="ttdef"><b>Definition:</b> fwd.hpp:139</div></div>
<div class="ttc" id="astructVertexArray_html_a3cd8e8e07596edcbeb6cab4b56a4242d"><div class="ttname"><a href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">VertexArray::vertexAttrib</a></div><div class="ttdeci">VertexAttrib vertexAttrib[maxAttributes]</div><div class="ttdoc">settings for vertex attributes</div><div class="ttdef"><b>Definition:</b> fwd.hpp:238</div></div>
<div class="ttc" id="afwd_8hpp_html_ad35fa691c90051fd7b24f95fb6c4b55d"><div class="ttname"><a href="fwd_8hpp.html#ad35fa691c90051fd7b24f95fb6c4b55d">pushBindProgramCommand</a></div><div class="ttdeci">void pushBindProgramCommand(CommandBuffer &amp;cb, uint32_t id)</div><div class="ttdoc">This function inserts bindProgram command into command buffer.</div><div class="ttdef"><b>Definition:</b> fwd.hpp:546</div></div>
<div class="ttc" id="astructImage_html_afe74defc826aae605cb2214cbf34c5eb"><div class="ttname"><a href="structImage.html#afe74defc826aae605cb2214cbf34c5eb">Image::Channel</a></div><div class="ttdeci">Channel</div><div class="ttdoc">Channel type.</div><div class="ttdef"><b>Definition:</b> fwd.hpp:35</div></div>
<div class="ttc" id="astructMesh_html_abc59ae5bf8f9b8d5b806e6e91ae5e1f5"><div class="ttname"><a href="structMesh.html#abc59ae5bf8f9b8d5b806e6e91ae5e1f5">Mesh::normal</a></div><div class="ttdeci">VertexAttrib normal</div><div class="ttdoc">normal vertex attribute</div><div class="ttdef"><b>Definition:</b> fwd.hpp:605</div></div>
<div class="ttc" id="astructGPUMemory_html_a7b289e72424eb0cf9b7aa920386f7565"><div class="ttname"><a href="structGPUMemory.html#a7b289e72424eb0cf9b7aa920386f7565">GPUMemory::activatedProgram</a></div><div class="ttdeci">uint32_t activatedProgram</div><div class="ttdoc">id of activated program</div><div class="ttdef"><b>Definition:</b> fwd.hpp:335</div></div>
<div class="ttc" id="astructVertexArray_html_a89b9faa058891874f5bf63064deafe99"><div class="ttname"><a href="structVertexArray.html#a89b9faa058891874f5bf63064deafe99">VertexArray::indexOffset</a></div><div class="ttdeci">uint64_t indexOffset</div><div class="ttdoc">offset of indices</div><div class="ttdef"><b>Definition:</b> fwd.hpp:240</div></div>
<div class="ttc" id="astructGPUMemory_html_ad9cda42fea22fb0d5347a91f101d15d2"><div class="ttname"><a href="structGPUMemory.html#ad9cda42fea22fb0d5347a91f101d15d2">GPUMemory::maxFramebuffers</a></div><div class="ttdeci">uint32_t maxFramebuffers</div><div class="ttdoc">maximal number of framebuffers</div><div class="ttdef"><b>Definition:</b> fwd.hpp:326</div></div>
<div class="ttc" id="astructInVertex_html_a4fc269d49110daa41aedf9b8f313f0ca"><div class="ttname"><a href="structInVertex.html#a4fc269d49110daa41aedf9b8f313f0ca">InVertex::attributes</a></div><div class="ttdeci">Attribute attributes[maxAttributes]</div><div class="ttdoc">vertex attributes</div><div class="ttdef"><b>Definition:</b> fwd.hpp:108</div></div>
<div class="ttc" id="astructFramebuffer_html_a614fd13812430c2ffb379b3b050780c4"><div class="ttname"><a href="structFramebuffer.html#a614fd13812430c2ffb379b3b050780c4">Framebuffer::height</a></div><div class="ttdeci">uint32_t height</div><div class="ttdoc">height of frame buffer</div><div class="ttdef"><b>Definition:</b> fwd.hpp:298</div></div>
<div class="ttc" id="astructInFragment_html_af9cd9e9a684a1c454d52d7e191564be1"><div class="ttname"><a href="structInFragment.html#af9cd9e9a684a1c454d52d7e191564be1">InFragment::attributes</a></div><div class="ttdeci">Attribute attributes[maxAttributes]</div><div class="ttdoc">fragment attributes</div><div class="ttdef"><b>Definition:</b> fwd.hpp:128</div></div>
<div class="ttc" id="astructImage_html_af20c22715fcc14fe41d929a5127ac897"><div class="ttname"><a href="structImage.html#af20c22715fcc14fe41d929a5127ac897">Image::channels</a></div><div class="ttdeci">uint32_t channels</div><div class="ttdoc">number of color channels</div><div class="ttdef"><b>Definition:</b> fwd.hpp:49</div></div>
<div class="ttc" id="astructGPUMemory_html"><div class="ttname"><a href="structGPUMemory.html">GPUMemory</a></div><div class="ttdoc">[Buffer]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:320</div></div>
<div class="ttc" id="astructCommand_html_ab4bcc3a5664498309ec42d4bb0e1c872"><div class="ttname"><a href="structCommand.html#ab4bcc3a5664498309ec42d4bb0e1c872">Command::data</a></div><div class="ttdeci">CommandData data</div><div class="ttdoc">data of the command</div><div class="ttdef"><b>Definition:</b> fwd.hpp:464</div></div>
<div class="ttc" id="astructGPUMemory_html_af2f8e1efb9217022ced48eeb04b79810"><div class="ttname"><a href="structGPUMemory.html#af2f8e1efb9217022ced48eeb04b79810">GPUMemory::activatedVertexArray</a></div><div class="ttdeci">uint32_t activatedVertexArray</div><div class="ttdoc">id of activated vertex array</div><div class="ttdef"><b>Definition:</b> fwd.hpp:336</div></div>
<div class="ttc" id="afwd_8hpp_html_ac2dd95ee5e44978647da13fc95b9420e"><div class="ttname"><a href="fwd_8hpp.html#ac2dd95ee5e44978647da13fc95b9420e">FragmentShader</a></div><div class="ttdeci">void(*)(OutFragment &amp;outFragment, InFragment const  &amp;inFragment, ShaderInterface const  &amp;si) FragmentShader</div><div class="ttdoc">[VertexShader]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:217</div></div>
<div class="ttc" id="aunionCommandData_html_a300ba13d9d8bb7dbdb61bd067a7a68e1"><div class="ttname"><a href="unionCommandData.html#a300ba13d9d8bb7dbdb61bd067a7a68e1">CommandData::bindProgramCommand</a></div><div class="ttdeci">BindProgramCommand bindProgramCommand</div><div class="ttdoc">bind program command</div><div class="ttdef"><b>Definition:</b> fwd.hpp:453</div></div>
<div class="ttc" id="astructInFragment_html_ae72e0b96e17181ea2cb2ef256e3f0a8f"><div class="ttname"><a href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">InFragment::gl_FragCoord</a></div><div class="ttdeci">glm::vec4 gl_FragCoord</div><div class="ttdoc">fragment coordinates</div><div class="ttdef"><b>Definition:</b> fwd.hpp:129</div></div>
<div class="ttc" id="astructBindVertexArrayCommand_html_a2dedaac94feb65b7c932753adba273e9"><div class="ttname"><a href="structBindVertexArrayCommand.html#a2dedaac94feb65b7c932753adba273e9">BindVertexArrayCommand::id</a></div><div class="ttdeci">uint32_t id</div><div class="ttdoc">selected vertex array - id</div><div class="ttdef"><b>Definition:</b> fwd.hpp:413</div></div>
<div class="ttc" id="astructBindProgramCommand_html"><div class="ttname"><a href="structBindProgramCommand.html">BindProgramCommand</a></div><div class="ttdoc">[BindFramebufferCommand]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:402</div></div>
<div class="ttc" id="astructMesh_html_ae334cf0d47655e3daefe644b574468d5"><div class="ttname"><a href="structMesh.html#ae334cf0d47655e3daefe644b574468d5">Mesh::indexOffset</a></div><div class="ttdeci">size_t indexOffset</div><div class="ttdoc">offset into index buffer</div><div class="ttdef"><b>Definition:</b> fwd.hpp:602</div></div>
<div class="ttc" id="afwd_8hpp_html_a21e038f5b8958e203d28bc4f18472352a2b4807f24940ca2fe73284bc6e864d66"><div class="ttname"><a href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352a2b4807f24940ca2fe73284bc6e864d66">CommandType::DRAW</a></div><div class="ttdeci">@ DRAW</div><div class="ttdoc">draw command</div></div>
<div class="ttc" id="aunionAttribute_html_a179957a4d2f0939276694bd8db6aecd1"><div class="ttname"><a href="unionAttribute.html#a179957a4d2f0939276694bd8db6aecd1">Attribute::u2</a></div><div class="ttdeci">glm::uvec2 u2</div><div class="ttdoc">vector of two unsigned ints</div><div class="ttdef"><b>Definition:</b> fwd.hpp:97</div></div>
<div class="ttc" id="aunionAttribute_html_a2a9e03282539207b21a9b61596e6b72c"><div class="ttname"><a href="unionAttribute.html#a2a9e03282539207b21a9b61596e6b72c">Attribute::v1</a></div><div class="ttdeci">float v1</div><div class="ttdoc">single float</div><div class="ttdef"><b>Definition:</b> fwd.hpp:92</div></div>
<div class="ttc" id="astructShaderInterface_html_acdb2c4b2df7bd9535ddde723b86eabc7"><div class="ttname"><a href="structShaderInterface.html#acdb2c4b2df7bd9535ddde723b86eabc7">ShaderInterface::gl_DrawID</a></div><div class="ttdeci">uint32_t gl_DrawID</div><div class="ttdoc">draw id</div><div class="ttdef"><b>Definition:</b> fwd.hpp:188</div></div>
<div class="ttc" id="astructGPUMemory_html_a8fa73be85fde25818e8b63d71fd7dd60"><div class="ttname"><a href="structGPUMemory.html#a8fa73be85fde25818e8b63d71fd7dd60">GPUMemory::maxTextures</a></div><div class="ttdeci">uint32_t maxTextures</div><div class="ttdoc">maximal number of textures</div><div class="ttdef"><b>Definition:</b> fwd.hpp:323</div></div>
<div class="ttc" id="aunionAttribute_html"><div class="ttname"><a href="unionAttribute.html">Attribute</a></div><div class="ttdoc">[AttributeType]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:90</div></div>
<div class="ttc" id="aunionUniform_html_a70392e438c775c6213e6c2dec76b29c4"><div class="ttname"><a href="unionUniform.html#a70392e438c775c6213e6c2dec76b29c4">Uniform::v3</a></div><div class="ttdeci">glm::vec3 v3</div><div class="ttdoc">three floats</div><div class="ttdef"><b>Definition:</b> fwd.hpp:151</div></div>
<div class="ttc" id="astructClearCommand_html_abce5e336f53ec4d984f19e1152e9647d"><div class="ttname"><a href="structClearCommand.html#abce5e336f53ec4d984f19e1152e9647d">ClearCommand::color</a></div><div class="ttdeci">glm::vec4 color</div><div class="ttdoc">color buffer will be cleared by this value</div><div class="ttdef"><b>Definition:</b> fwd.hpp:359</div></div>
<div class="ttc" id="astructMesh_html_abc3edaf6225dd67400f33e59edc598c4"><div class="ttname"><a href="structMesh.html#abc3edaf6225dd67400f33e59edc598c4">Mesh::doubleSided</a></div><div class="ttdeci">bool doubleSided</div><div class="ttdoc">double sided material</div><div class="ttdef"><b>Definition:</b> fwd.hpp:610</div></div>
<div class="ttc" id="astructInVertex_html"><div class="ttname"><a href="structInVertex.html">InVertex</a></div><div class="ttdoc">[Attribute]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:107</div></div>
<div class="ttc" id="aunionUniform_html_aec09b95ed538f79020d6e70323b27771"><div class="ttname"><a href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">Uniform::m4</a></div><div class="ttdeci">glm::mat4 m4</div><div class="ttdoc">4x4 float matrix</div><div class="ttdef"><b>Definition:</b> fwd.hpp:161</div></div>
<div class="ttc" id="astructModel_html"><div class="ttname"><a href="structModel.html">Model</a></div><div class="ttdoc">[Node]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:629</div></div>
<div class="ttc" id="afwd_8hpp_html_a21e038f5b8958e203d28bc4f18472352"><div class="ttname"><a href="fwd_8hpp.html#a21e038f5b8958e203d28bc4f18472352">CommandType</a></div><div class="ttdeci">CommandType</div><div class="ttdoc">[SubCommand]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:431</div></div>
<div class="ttc" id="astructMesh_html_a00f5a9d0221fc4e66dc165520a835460"><div class="ttname"><a href="structMesh.html#a00f5a9d0221fc4e66dc165520a835460">Mesh::position</a></div><div class="ttdeci">VertexAttrib position</div><div class="ttdoc">position vertex attribute</div><div class="ttdef"><b>Definition:</b> fwd.hpp:604</div></div>
<div class="ttc" id="astructMesh_html_a55de606f67f2aa169ef7b51042ade990"><div class="ttname"><a href="structMesh.html#a55de606f67f2aa169ef7b51042ade990">Mesh::indexType</a></div><div class="ttdeci">IndexType indexType</div><div class="ttdoc">type of indices</div><div class="ttdef"><b>Definition:</b> fwd.hpp:603</div></div>
<div class="ttc" id="agpu_8cpp_html_a534f9ebe20a4f57bd73b4dfb9bb4b29b"><div class="ttname"><a href="gpu_8cpp.html#a534f9ebe20a4f57bd73b4dfb9bb4b29b">izg_enqueue</a></div><div class="ttdeci">void izg_enqueue(GPUMemory &amp;mem, CommandBuffer const &amp;cb)</div><div class="ttdoc">[izg_enqueue]</div><div class="ttdef"><b>Definition:</b> gpu.cpp:12</div></div>
<div class="ttc" id="afwd_8hpp_html_ad5d24f6d5d3b90ad155197ce8edf694c"><div class="ttname"><a href="fwd_8hpp.html#ad5d24f6d5d3b90ad155197ce8edf694c">pushDrawCommand</a></div><div class="ttdeci">void pushDrawCommand(CommandBuffer &amp;cb, uint32_t nofVertices, bool backfaceCulling=false)</div><div class="ttdoc">This function can be used to insert draw command into command buffer.</div><div class="ttdef"><b>Definition:</b> fwd.hpp:514</div></div>
<div class="ttc" id="astructSetDrawIdCommand_html"><div class="ttname"><a href="structSetDrawIdCommand.html">SetDrawIdCommand</a></div><div class="ttdoc">[DrawCommand]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:382</div></div>
<div class="ttc" id="astructImage_html_add6fee24fd0db09ee35432b6541e5018"><div class="ttname"><a href="structImage.html#add6fee24fd0db09ee35432b6541e5018">Image::bytesPerPixel</a></div><div class="ttdeci">uint32_t bytesPerPixel</div><div class="ttdoc">size of pixel in bytes</div><div class="ttdef"><b>Definition:</b> fwd.hpp:53</div></div>
<div class="ttc" id="astructGPUMemory_html_a3798310241309de18f5561931d1d2665"><div class="ttname"><a href="structGPUMemory.html#a3798310241309de18f5561931d1d2665">GPUMemory::maxVertexArrays</a></div><div class="ttdeci">uint32_t maxVertexArrays</div><div class="ttdoc">maximal number of vertex arrays</div><div class="ttdef"><b>Definition:</b> fwd.hpp:322</div></div>
<div class="ttc" id="astructModel_html_a39a2739a54833484f1ce7f951cf58e1e"><div class="ttname"><a href="structModel.html#a39a2739a54833484f1ce7f951cf58e1e">Model::buffers</a></div><div class="ttdeci">std::vector&lt; Buffer &gt; buffers</div><div class="ttdoc">list of all buffers in model</div><div class="ttdef"><b>Definition:</b> fwd.hpp:633</div></div>
<div class="ttc" id="afwd_8hpp_html_addfd10ead04eeadec78064481a4a3f4daba2b45bdc11e2a4a6e86aab2ac693cbb"><div class="ttname"><a href="fwd_8hpp.html#addfd10ead04eeadec78064481a4a3f4daba2b45bdc11e2a4a6e86aab2ac693cbb">AttributeType::EMPTY</a></div><div class="ttdeci">@ EMPTY</div><div class="ttdoc">disabled attribute</div></div>
<div class="ttc" id="astructNode_html_a825a38e1f0d49fcc1a0cdbad46473bf2"><div class="ttname"><a href="structNode.html#a825a38e1f0d49fcc1a0cdbad46473bf2">Node::modelMatrix</a></div><div class="ttdeci">glm::mat4 modelMatrix</div><div class="ttdoc">model transformation matrix</div><div class="ttdef"><b>Definition:</b> fwd.hpp:619</div></div>
<div class="ttc" id="aunionCommandData_html"><div class="ttname"><a href="unionCommandData.html">CommandData</a></div><div class="ttdoc">[CommandType]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:447</div></div>
<div class="ttc" id="astructFramebuffer_html"><div class="ttname"><a href="structFramebuffer.html">Framebuffer</a></div><div class="ttdoc">This structure represent a framebuffer A framebuffer is used as an output of rendering.</div><div class="ttdef"><b>Definition:</b> fwd.hpp:294</div></div>
<div class="ttc" id="aunionCommandData_html_a8c895d0453562852f0082254858de113"><div class="ttname"><a href="unionCommandData.html#a8c895d0453562852f0082254858de113">CommandData::subCommand</a></div><div class="ttdeci">SubCommand subCommand</div><div class="ttdoc">sub command buffer</div><div class="ttdef"><b>Definition:</b> fwd.hpp:455</div></div>
<div class="ttc" id="astructCommandBuffer_html"><div class="ttname"><a href="structCommandBuffer.html">CommandBuffer</a></div><div class="ttdoc">[Command]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:475</div></div>
<div class="ttc" id="astructGPUMemory_html_a50091de928f20fa9d84c6bd137dab3a6"><div class="ttname"><a href="structGPUMemory.html#a50091de928f20fa9d84c6bd137dab3a6">GPUMemory::programs</a></div><div class="ttdeci">Program * programs</div><div class="ttdoc">array of all programs</div><div class="ttdef"><b>Definition:</b> fwd.hpp:331</div></div>
<div class="ttc" id="astructClearCommand_html_a2e5b422adedf1413c8cb8f6d47b5a09c"><div class="ttname"><a href="structClearCommand.html#a2e5b422adedf1413c8cb8f6d47b5a09c">ClearCommand::clearColor</a></div><div class="ttdeci">bool clearColor</div><div class="ttdoc">is color cleaning enabled?</div><div class="ttdef"><b>Definition:</b> fwd.hpp:361</div></div>
<div class="ttc" id="astructGPUMemory_html_ac07704dd918f18a48644abdabbdf6f0d"><div class="ttname"><a href="structGPUMemory.html#ac07704dd918f18a48644abdabbdf6f0d">GPUMemory::textures</a></div><div class="ttdeci">Texture * textures</div><div class="ttdoc">array of all textures</div><div class="ttdef"><b>Definition:</b> fwd.hpp:329</div></div>
<div class="ttc" id="astructNode_html_af7ddc81358470c3bf7a7819c8b77f53d"><div class="ttname"><a href="structNode.html#af7ddc81358470c3bf7a7819c8b77f53d">Node::children</a></div><div class="ttdeci">std::vector&lt; Node &gt; children</div><div class="ttdoc">list of children nodes</div><div class="ttdef"><b>Definition:</b> fwd.hpp:621</div></div>
<div class="ttc" id="astructOutFragment_html"><div class="ttname"><a href="structOutFragment.html">OutFragment</a></div><div class="ttdoc">[InFragment]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:137</div></div>
<div class="ttc" id="astructGPUMemory_html_acd06344c1c43bef8df606d6664fee4b4"><div class="ttname"><a href="structGPUMemory.html#acd06344c1c43bef8df606d6664fee4b4">GPUMemory::activatedFramebuffer</a></div><div class="ttdeci">uint32_t activatedFramebuffer</div><div class="ttdoc">id of activated framebuffer</div><div class="ttdef"><b>Definition:</b> fwd.hpp:334</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 9 2024 14:46:35 for Izg project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
